<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="future.zhangyan">



    <meta name="description" content="未来可期">



<title>python高级 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.1.1"></head>

<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">张艳&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/book">Book</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">张艳&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                    <a class="menu-item" href="/book">Book</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">python高级</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">future.zhangyan</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 15, 2020&nbsp;&nbsp;20:29:14</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="Python-中类方法、类实例方法、静态方法有何区别？"><a href="#Python-中类方法、类实例方法、静态方法有何区别？" class="headerlink" title="Python 中类方法、类实例方法、静态方法有何区别？"></a>Python 中类方法、类实例方法、静态方法有何区别？</h3><p>类方法：是类对象的方法，在定义时需要在上方使用“@classmethod”进行装饰，形参为 cls， 表示类对象，类对象和实例对象都可调用； </p>
<p>类实例方法：是类实例化对象的方法，只有实例对象可以调用，形参为 self，指代对象本身； </p>
<p>静态方法：是一个任意函数，在其上方使用“@staticmethod”进行装饰，可以用对象直接调用， 静态方法实际上跟该类没有太大关系。</p>
<h3 id="Python-的内存管理机制及调优手段？"><a href="#Python-的内存管理机制及调优手段？" class="headerlink" title="Python 的内存管理机制及调优手段？"></a>Python 的内存管理机制及调优手段？</h3><p>内存管理机制：引用计数、垃圾回收、内存池。 引用计数： 引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加 1， 当 其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。 </p>
<p>垃圾回收 ： </p>
<ol>
<li>引用计数 引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 的某 个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如 某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0， 那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了</li>
</ol>
<ol start="2">
<li>标记清除 如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被 回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引 用摘掉，就会得出这两个对象的有效计数。</li>
</ol>
<ol start="3">
<li>分代回收 从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统 中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾 回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额 外操作</li>
</ol>
<p>举个例子： </p>
<p>当某些内存块 M 经过了 3 次垃圾收集的清洗之后还存活时，我们就将内存块 M 划到一个集合 A 中去，而新分配的内存都划分到集合 B 中去。当垃圾收集开始工作时，大多数情况都只对集合 B 进 行垃圾回收，而对集合 A 进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处 理的内存少了，效率自然就提高了。在这个过程中，集合 B 中的某些内存块由于存活时间长而会被转 移到集合 A 中，当然，集合 A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而 被延迟。 </p>
<p>内存池： </p>
<ol>
<li>Python 的内存机制呈现金字塔形状，-1，-2 层主要有操作系统进行操作；</li>
</ol>
<ol start="2">
<li>第 0 层是 C 中的 malloc，free 等内存分配和释放函数进行操作；</li>
</ol>
<ol start="3">
<li>第 1 层和第 2 层是内存池，有 Python 的接口函数 PyMem_Malloc 函数实现，当对象小于 256K 时有该层直接分配内存；</li>
</ol>
<ol start="4">
<li>第 3 层是最上层，也就是我们对 Python 对象的直接操作；</li>
</ol>
<p>Python 在运行期间会大量地执行 malloc 和 free 的操作，频繁地在用户态和核心态之间进行</p>
<p>切换，这将严重影响 Python 的执行效率。为了加速 Python 的执行效率，Python 引入了一个内存池机制，用于管理对小块内存的申请和释放。Python 内部默认的小块内存与大块内存的分界点定在 256 个字节，当申请的内存小于 256 字节时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于 256 字节时， PyObject_Malloc 的行为将蜕化为 malloc 的行为。当然，通过修改 Python 源代码，我们可以改变这个默认值，从而改变 Python 的默认内存管理行为。</p>
<p>调优手段（了解） </p>
<p>1.手动垃圾回收 </p>
<p>2.调高垃圾回收阈值 </p>
<p>3.避免循环引用（手动解循环引用和使用弱引用） </p>
<h3 id="内存泄露是什么？如何避免？"><a href="#内存泄露是什么？如何避免？" class="headerlink" title="内存泄露是什么？如何避免？"></a>内存泄露是什么？如何避免？</h3><p>指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的 消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。导致程序运行速度减慢甚至系统崩溃等严重后果。 有 del() 函数的对象间的循环引用是导致内存泄漏的主凶。 不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。 通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息。 可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为 0 来判断是否内存 泄漏。</p>
<h3 id="Python-函数调用的时候参数的传递方式是值传递还是引用传递？"><a href="#Python-函数调用的时候参数的传递方式是值传递还是引用传递？" class="headerlink" title="Python 函数调用的时候参数的传递方式是值传递还是引用传递？"></a>Python 函数调用的时候参数的传递方式是值传递还是引用传递？</h3><p>Python 的参数传递有：位置参数、默认参数、可变参数、关键字参数。 </p>
<p>函数的传值到底是值传递还是引用传递，要分情况</p>
<p>不可变参数用值传递： </p>
<p>像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变 </p>
<p>不可变对象 可变参数是引用传递的： 比如像列表，字典这样的对象是通过引用传递、和 C 语言里面的用指针传递数组很相似，可变对象 能在函数内部改变。</p>
<h3 id="对缺省参数的理解-？"><a href="#对缺省参数的理解-？" class="headerlink" title="对缺省参数的理解 ？"></a>对缺省参数的理解 ？</h3><p>缺省参数指在调用函数的时候没有传入参数的情况下，调用默认的参数，在调用函数的同时赋值时，所传入的参数会替代默认参数。 *args 是不定长参数，他可以表示输入参数是不确定的，可以是任意多个。 **kwargs 是关键字参数，赋值的时候是以键 = 值的方式，参数是可以任意多对在定义函数的时候 不确定会有多少参数会传入时，就可以使用两个参数。</p>
<h3 id="为什么函数名字可以当做参数用"><a href="#为什么函数名字可以当做参数用" class="headerlink" title="为什么函数名字可以当做参数用?"></a>为什么函数名字可以当做参数用?</h3><p>Python 中一切皆对象，函数名是函数在内存中的空间，也是一个对象。</p>
<h3 id="map-函数和-reduce-函数？"><a href="#map-函数和-reduce-函数？" class="headerlink" title="map 函数和 reduce 函数？"></a>map 函数和 reduce 函数？</h3><p>①从参数方面来讲： map()包含两个参数，第一个参数是一个函数，第二个是序列（列表 或元组）。其中，函数（即 map 的第一个参数位置的函数）可以接收一个或多个参数。 reduce()第一个参数是函数，第二个是序列（列表或元组）。但是，其函数必须接收两个参数。 ②从对传进去的数值作用来讲： map()是将传入的函数依次作用到序列的每个元素，每个元素都是独自被函数“作用”一次 。reduce()是将传人的函数作用在序列的第一个元素得到结果后，把这个结果继续与下一个元素作用（累积计算）。</p>
<h3 id="递归函数停止的条件？"><a href="#递归函数停止的条件？" class="headerlink" title="递归函数停止的条件？"></a>递归函数停止的条件？</h3><p>递归的终止条件一般定义在递归函数内部，在递归调用前要做一个条件判断，根据判断的结果选择 是继续调用自身，还是 return;返回终止递归。 </p>
<p>终止的条件：</p>
<ol>
<li>判断递归的次数是否达到某一限定值</li>
</ol>
<ol start="2">
<li>判断运算的结果是否达到某个范围等，根据设计的目的来选择</li>
</ol>
<h3 id="回调函数，如何通信的"><a href="#回调函数，如何通信的" class="headerlink" title="回调函数，如何通信的?"></a>回调函数，如何通信的?</h3><p>回调函数是把函数的地址作为参数传递给另一个函数，将整个函数当作一个对象，赋值给调用的函数。</p>
<h3 id="什么是-lambda-函数？-有什么好处？"><a href="#什么是-lambda-函数？-有什么好处？" class="headerlink" title="什么是 lambda 函数？ 有什么好处？"></a>什么是 lambda 函数？ 有什么好处？</h3><p>lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数 1、lambda函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用， 连名字都很随意的情况下； 2、匿名函数，一般用来给 filter， map 这样的函数式编程服务; 3、作为回调函数，传递给某些应用，比如消息处理</p>
<h3 id="单例模式的应用场景有哪些？"><a href="#单例模式的应用场景有哪些？" class="headerlink" title="单例模式的应用场景有哪些？"></a>单例模式的应用场景有哪些？</h3><p>单例模式应用的场景一般发现在以下条件下： （1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。 （2）控制资源的情况下，方便资源之间的互相通信。如线程池等。 1.网站的计数器 2.应用配置 3.多线程池 4. 数据库配置，数据库连接池 5.应用程序的日志应用….</p>
<h3 id="函数装饰器有什么作用？"><a href="#函数装饰器有什么作用？" class="headerlink" title="函数装饰器有什么作用？"></a>函数装饰器有什么作用？</h3><p>装饰器本质上是一个 Python 函数，它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能。装 饰器的返回值也是一个函数的对象，它经常用于有切面需求的场景。 比如：插入日志、性能测试、事务处理、缓存、 权限的校验等场景 有了装饰器就可以抽离出大量的与函数功能本身无关的雷同代码并发并继续使用。</p>
<h3 id="生成器、迭代器的区别？"><a href="#生成器、迭代器的区别？" class="headerlink" title="生成器、迭代器的区别？"></a>生成器、迭代器的区别？</h3><p>迭代器是一个更抽象的概念，任何对象，如果它的类有 next 方法和 iter 方法返回自己本身，对于string、list、 dict、tuple 等这类容器对象，使用 for 循环遍历是很方便的。在后台 for 语句对容器对象调用 iter()函数，iter() 是 python 的内置函数。iter()会返回一个定义了 next()方法的迭代器对象，它在容器中逐个访问容器内元素，next() 也是 python 的内置函数。在没有后续元素时，next()会抛出一个 StopIteration 异常。 生成器（Generator）是创建迭代器的简单而强大的工具。它们写起来就像是正规的函数，只是在需要返回数 据的时候使用 yield 语句。每次 next()被调用时，生成器</p>
<p>会返回它脱离的位置（它记忆语句最后一次执行的位置 和所有的数据值） 区别：生成器能做到迭代器能做的所有事,而且因为自动创建了 iter()和 next()方法,生成器显得特别简洁,而且 生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法,当 发生器终结时,还会自动抛出 StopIteration 异常。</p>
<h3 id="Python-中-yield-的用法？"><a href="#Python-中-yield-的用法？" class="headerlink" title="Python 中 yield 的用法？"></a>Python 中 yield 的用法？</h3><p>yield 就是保存当前程序执行状态。你用 for 循环的时候，每次取一个元素的时候就会计算一次。用 yield 的函数 叫 generator，和 iterator 一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间。generator 每次计算需要上一次计算结果，所以用 yield，否则一 return，上次计算结果就没了。</p>
<h3 id="Python-中的可变对象和不可变对象？"><a href="#Python-中的可变对象和不可变对象？" class="headerlink" title="Python 中的可变对象和不可变对象？"></a>Python 中的可变对象和不可变对象？</h3><p>不可变对象，该对象所指向的内存中的值不能被改变。当改变某个变量时候，由于其所指的值不能被改变，相当 于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。 可变对象，该对象所指向的内存中的值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接 发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。</p>
<p>Python 中，数值类型（int 和 float）、字符串 str、元组 tuple 都是不可变类型。而列表 list、字典dict、集合 set 是可变类型。</p>
<h3 id="Python-中-is-和-的区别？"><a href="#Python-中-is-和-的区别？" class="headerlink" title="Python 中 is 和==的区别？"></a>Python 中 is 和==的区别？</h3><p>is 判断的是 a 对象是否就是 b 对象，是通过 id 来判断的。 ==判断的是 a 对象的值是否和 b 对象的值相等，是通过 value 来判断的。</p>
<h3 id="Python-的魔法方法"><a href="#Python-的魔法方法" class="headerlink" title="Python 的魔法方法"></a>Python 的魔法方法</h3><p>魔法方法就是可以给你的类增加魔力的特殊方法，如果你的对象实现 （重载）了这些方法中的某一个，那么这个 方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。 它们经常是 两个下划线包围来命名的（比如 init，lt），Python 的魔法方法是非常强大的，所以了解其使用方法也变得 尤为重要！</p>
<p>init 构造器，当一个实例被创建的时候初始化的方法。但是它并 不是实例化调用的第一个方法。new才是实例化对象调用的第一个方法，它只取下 cls 参数，并把 其他参数传给 init。 new很少使用，但是也有它适合的场景，尤其 是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。 call 允许一个类的实例像函数一样被调用 。 getitem 定义获取容器中指定元素的行为，相当于 self[key] 。 getattr 定义当用户试图访问一个不存在属性的时候的行为 。 setattr 定义当一个属性被设置的时候的行为 。 getattribute 定义当一个属性被访问的时候的行为 。</p>
<h3 id="谈谈你对面向对象的理解？"><a href="#谈谈你对面向对象的理解？" class="headerlink" title="谈谈你对面向对象的理解？"></a>谈谈你对面向对象的理解？</h3><p>面向对象是相对于面向过程而言的。面向过程语言是一种基于功能分析的、以算法为中心的程序设计方法；而面 向对象是一种基于结构分析的、以数据为中心的程序设计思想。在面向对象语言中有一个有很重要东西，叫做类。 面向对象有三大特性：封装、继承、多态。</p>
<h3 id="Python-里-match-与-search-的区别？"><a href="#Python-里-match-与-search-的区别？" class="headerlink" title="Python 里 match 与 search 的区别？"></a>Python 里 match 与 search 的区别？</h3><p>match()函数只检测 RE 是不是在 string 的开始位置匹配， search()会扫描整个 string 查找匹配；也就是说 match()只有在 0 位置匹配成功的话才有返回， 如果不是开始位置匹配成功的话，match()就返回 none。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>future.zhangyan</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://zhangyanlady.github.io/2020/09/15/python%E9%AB%98%E7%BA%A7/">https://zhangyanlady.github.io/2020/09/15/python%E9%AB%98%E7%BA%A7/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>The future can be expected, the world is worth it.</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/09/15/%E7%88%AC%E8%99%AB/">爬虫</a>
            
            
            <a class="next" rel="next" href="/2020/09/15/vue/">vue</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© future.zhangyan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
